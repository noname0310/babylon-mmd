(()=>{"use strict";var e,t,n,r={7198:(e,t,n)=>{n.d(t,{B:()=>r});const r="\n#ifndef SDEFDECLARATION\n#define SDEFDECLARATION\n#if NUM_BONE_INFLUENCERS>0 && defined(SDEF)\nattribute matricesSdefC: vec3f;attribute matricesSdefRW0: vec3f;attribute matricesSdefRW1: vec3f;fn rotationMatrixToQuaternion(matrix: mat3x3f)->vec4f {let trace: f32=matrix[0][0]+matrix[1][1]+matrix[2][2];var s: f32;var sqrtParam: f32;if (trace>0.0) {sqrtParam=trace+1.0;} else if (matrix[0][0]>matrix[1][1] && matrix[0][0]>matrix[2][2]) {sqrtParam=1.0+matrix[0][0]-matrix[1][1]-matrix[2][2];} else if (matrix[1][1]>matrix[2][2]) {sqrtParam=1.0+matrix[1][1]-matrix[0][0]-matrix[2][2];} else {sqrtParam=1.0+matrix[2][2]-matrix[0][0]-matrix[1][1];}\nlet sqrtValue: f32=sqrt(sqrtParam);if (trace>0.0) {s=0.5/sqrtValue;return vec4f(\n(matrix[1][2]-matrix[2][1])*s,\n(matrix[2][0]-matrix[0][2])*s,\n(matrix[0][1]-matrix[1][0])*s,\n0.25/s\n);} else if (matrix[0][0]>matrix[1][1] && matrix[0][0]>matrix[2][2]) {s=2.0*sqrtValue;return vec4f(\n0.25*s,\n(matrix[0][1]+matrix[1][0])/s,\n(matrix[2][0]+matrix[0][2])/s,\n(matrix[1][2]-matrix[2][1])/s\n);} else if (matrix[1][1]>matrix[2][2]) {s=2.0*sqrtValue;return vec4f(\n(matrix[0][1]+matrix[1][0])/s,\n0.25*s,\n(matrix[1][2]+matrix[2][1])/s,\n(matrix[2][0]-matrix[0][2])/s\n);} else {s=2.0*sqrtValue;return vec4f(\n(matrix[2][0]+matrix[0][2])/s,\n(matrix[1][2]+matrix[2][1])/s,\n0.25*s,\n(matrix[0][1]-matrix[1][0])/s\n);}}\nfn quaternionToRotationMatrix(q: vec4f)->mat3x3f {let xx: f32=q.x*q.x;let yy: f32=q.y*q.y;let zz: f32=q.z*q.z;let xy: f32=q.x*q.y;let zw: f32=q.z*q.w;let zx: f32=q.z*q.x;let yw: f32=q.y*q.w;let yz: f32=q.y*q.z;let xw: f32=q.x*q.w;return mat3x3f(\n1.0-2.0*(yy+zz),2.0*(xy+zw),2.0*(zx-yw),\n2.0*(xy-zw),1.0-2.0*(zz+xx),2.0*(yz+xw),\n2.0*(zx+yw),2.0*(yz-xw),1.0-2.0*(yy+xx)\n);}\nfn slerp(q0: vec4f,_q1: vec4f,t: f32)->vec4f {var q1: vec4f=_q1;var cosTheta: f32=dot(q0,q1);q1=mix(-q1,q1,step(0.0,cosTheta));cosTheta=abs(cosTheta);if (cosTheta>0.999999) {return normalize(mix(q0,q1,t));}\nvar theta: f32=acos(cosTheta);var sinTheta: f32=sin(theta);var w0: f32=sin((1.0-t)*theta)/sinTheta;var w1: f32=sin(t*theta)/sinTheta;return q0*w0+q1*w1;}\n#endif\n#endif\n"},4122:(e,t,n)=>{n.d(t,{Z:()=>r});const r="\n#ifndef SDEFVERTEX\n#define SDEFVERTEX\n#if !defined(BAKED_VERTEX_ANIMATION_TEXTURE) && defined(SDEF)\n#if NUM_BONE_INFLUENCERS>0\n{let weight0: f32=vertexInputs.matricesWeights[0];let weight1: f32=vertexInputs.matricesWeights[1];\n#ifdef BONETEXTURE\nlet transformMatrix0: mat4x4f=readMatrixFromRawSampler(boneSampler,vertexInputs.matricesIndices[0]);let transformMatrix1: mat4x4f=readMatrixFromRawSampler(boneSampler,vertexInputs.matricesIndices[1]);\n#else\nlet transformMatrix0: mat4x4f=uniforms.mBones[int(vertexInputs.matricesIndices[0])];let transformMatrix1: mat4x4f=uniforms.mBones[int(vertexInputs.matricesIndices[1])];\n#endif\nlet slerpedRotationMatrix: mat3x3f=quaternionToRotationMatrix(slerp(\nrotationMatrixToQuaternion(mat3x3f(transformMatrix0[0].xyz,transformMatrix0[1].xyz,transformMatrix0[2].xyz)),\nrotationMatrixToQuaternion(mat3x3f(transformMatrix1[0].xyz,transformMatrix1[1].xyz,transformMatrix1[2].xyz)),\nweight1\n));var sdefInflunce: mat4x4f=mat4x4f(\nvec4f(1.0,0.0,0.0,0.0),\nvec4f(0.0,1.0,0.0,0.0),\nvec4f(0.0,0.0,1.0,0.0),\nvec4f(-vertexInputs.matricesSdefC,1.0)\n);let rotationMatrix: mat4x4f=mat4x4f(\nvec4f(slerpedRotationMatrix[0],0.0),\nvec4f(slerpedRotationMatrix[1],0.0),\nvec4f(slerpedRotationMatrix[2],0.0),\nvec4f(0.0,0.0,0.0,1.0)\n);sdefInflunce=rotationMatrix*sdefInflunce;let positionOffset: vec3f =\n(transformMatrix0*vec4f(vertexInputs.matricesSdefRW0,1)).xyz*weight0 +\n(transformMatrix1*vec4f(vertexInputs.matricesSdefRW1,1)).xyz*weight1;sdefInflunce[3]+=vec4f(positionOffset,0.0);let useLinearDeform: f32=step(0.0,-abs(vertexInputs.matricesSdefRW0.x));influence=mat4x4f(\nmix(sdefInflunce[0],influence[0],useLinearDeform),\nmix(sdefInflunce[1],influence[1],useLinearDeform),\nmix(sdefInflunce[2],influence[2],useLinearDeform),\nmix(sdefInflunce[3],influence[3],useLinearDeform)\n);}\n#endif\n#endif\n#endif\n"},9339:(e,t,n)=>{n.d(t,{B:()=>r});const r="\n#ifndef SDEFDECLARATION\n#define SDEFDECLARATION\n#if NUM_BONE_INFLUENCERS>0 && defined(SDEF)\nattribute vec3 matricesSdefC;attribute vec3 matricesSdefRW0;attribute vec3 matricesSdefRW1;vec4 rotationMatrixToQuaternion(mat3 matrix) {float trace=matrix[0][0]+matrix[1][1]+matrix[2][2];float s;float sqrtParam;if (trace>0.0) {sqrtParam=trace+1.0;} else if (matrix[0][0]>matrix[1][1] && matrix[0][0]>matrix[2][2]) {sqrtParam=1.0+matrix[0][0]-matrix[1][1]-matrix[2][2];} else if (matrix[1][1]>matrix[2][2]) {sqrtParam=1.0+matrix[1][1]-matrix[0][0]-matrix[2][2];} else {sqrtParam=1.0+matrix[2][2]-matrix[0][0]-matrix[1][1];}\nfloat sqrtValue=sqrt(sqrtParam);if (trace>0.0) {s=0.5/sqrtValue;return vec4(\n(matrix[1][2]-matrix[2][1])*s,\n(matrix[2][0]-matrix[0][2])*s,\n(matrix[0][1]-matrix[1][0])*s,\n0.25/s\n);} else if (matrix[0][0]>matrix[1][1] && matrix[0][0]>matrix[2][2]) {s=2.0*sqrtValue;return vec4(\n0.25*s,\n(matrix[0][1]+matrix[1][0])/s,\n(matrix[2][0]+matrix[0][2])/s,\n(matrix[1][2]-matrix[2][1])/s\n);} else if (matrix[1][1]>matrix[2][2]) {s=2.0*sqrtValue;return vec4(\n(matrix[0][1]+matrix[1][0])/s,\n0.25*s,\n(matrix[1][2]+matrix[2][1])/s,\n(matrix[2][0]-matrix[0][2])/s\n);} else {s=2.0*sqrtValue;return vec4(\n(matrix[2][0]+matrix[0][2])/s,\n(matrix[1][2]+matrix[2][1])/s,\n0.25*s,\n(matrix[0][1]-matrix[1][0])/s\n);}}\nmat3 quaternionToRotationMatrix(vec4 q) {float xx=q.x*q.x;float yy=q.y*q.y;float zz=q.z*q.z;float xy=q.x*q.y;float zw=q.z*q.w;float zx=q.z*q.x;float yw=q.y*q.w;float yz=q.y*q.z;float xw=q.x*q.w;return mat3(\n1.0-2.0*(yy+zz),2.0*(xy+zw),2.0*(zx-yw),\n2.0*(xy-zw),1.0-2.0*(zz+xx),2.0*(yz+xw),\n2.0*(zx+yw),2.0*(yz-xw),1.0-2.0*(yy+xx)\n);}\nvec4 slerp(vec4 q0,vec4 q1,float t) {float cosTheta=dot(q0,q1);q1=mix(-q1,q1,step(0.0,cosTheta));cosTheta=abs(cosTheta);if (cosTheta>0.999999) {return normalize(mix(q0,q1,t));}\nfloat theta=acos(cosTheta);float sinTheta=sin(theta);float w0=sin((1.0-t)*theta)/sinTheta;float w1=sin(t*theta)/sinTheta;return q0*w0+q1*w1;}\n#endif\n#endif\n"},5041:(e,t,n)=>{n.d(t,{Z:()=>r});const r="\n#ifndef SDEFVERTEX\n#define SDEFVERTEX\n#if !defined(BAKED_VERTEX_ANIMATION_TEXTURE) && defined(SDEF)\n#if NUM_BONE_INFLUENCERS>0\n{float weight0=matricesWeights[0];float weight1=matricesWeights[1];\n#ifdef BONETEXTURE\nmat4 transformMatrix0=readMatrixFromRawSampler(boneSampler,matricesIndices[0]);mat4 transformMatrix1=readMatrixFromRawSampler(boneSampler,matricesIndices[1]);\n#else\nmat4 transformMatrix0=mBones[int(matricesIndices[0])];mat4 transformMatrix1=mBones[int(matricesIndices[1])];\n#endif\nmat3 slerpedRotationMatrix=quaternionToRotationMatrix(slerp(\nrotationMatrixToQuaternion(mat3(transformMatrix0)),\nrotationMatrixToQuaternion(mat3(transformMatrix1)),\nweight1\n));mat4 sdefInflunce=mat4(\nvec4(1.0,0.0,0.0,0.0),\nvec4(0.0,1.0,0.0,0.0),\nvec4(0.0,0.0,1.0,0.0),\nvec4(-matricesSdefC,1.0)\n);mat4 rotationMatrix=mat4(\nvec4(slerpedRotationMatrix[0],0.0),\nvec4(slerpedRotationMatrix[1],0.0),\nvec4(slerpedRotationMatrix[2],0.0),\nvec4(0.0,0.0,0.0,1.0)\n);sdefInflunce=rotationMatrix*sdefInflunce;vec3 positionOffset =\nvec3(transformMatrix0*vec4(matricesSdefRW0,1))*weight0 +\nvec3(transformMatrix1*vec4(matricesSdefRW1,1))*weight1;sdefInflunce[3]+=vec4(positionOffset,0.0);float useLinearDeform=step(0.0,-abs(matricesSdefRW0.x));influence=mat4(\nmix(sdefInflunce[0],influence[0],useLinearDeform),\nmix(sdefInflunce[1],influence[1],useLinearDeform),\nmix(sdefInflunce[2],influence[2],useLinearDeform),\nmix(sdefInflunce[3],influence[3],useLinearDeform)\n);}\n#endif\n#endif\n#endif\n"},3036:(e,t,n)=>{n.d(t,{V:()=>r});class r{static AdditionalUV1Kind="additionalUv1";static AdditionalUV2Kind="additionalUv2";static AdditionalUV3Kind="additionalUv3";static AdditionalUV4Kind="additionalUv4";static MatricesSdefCKind="matricesSdefC";static MatricesSdefRW0Kind="matricesSdefRW0";static MatricesSdefRW1Kind="matricesSdefRW1";static MatricesSdefR0Kind="matricesSdefR0";static MatricesSdefR1Kind="matricesSdefR1";static EdgeScaleKind="edgeScale"}},426:(e,t,n)=>{n.d(t,{ZL:()=>p,rw:()=>r});var r,i=n(6125),s=n(9526),o=n(2277),a=n(6041),l=n(9259),d=n(6552),h=n(3036),c=function(e,t,n,r){var i,s=arguments.length,o=s<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,r);else for(var a=e.length-1;a>=0;a--)(i=e[a])&&(o=(s<3?i(o):s>3?i(t,n,o):i(t,n))||o);return s>3&&o&&Object.defineProperty(t,n,o),o};class u extends s.M{SPHERE_TEXTURE=!1;SPHERE_TEXTURE_BLEND_MODE_MULTIPLY=!1;SPHERE_TEXTURE_BLEND_MODE_ADD=!1;TOON_TEXTURE=!1;IGNORE_DIFFUSE_WHEN_TOON_TEXTURE_DISABLED=!1;APPLY_AMBIENT_COLOR_TO_DIFFUSE=!1;CLAMP_ALPHA=!1;TEXTURE_COLOR=!1;SPHERE_TEXTURE_COLOR=!1;TOON_TEXTURE_COLOR=!1;SDEF=!1}!function(e){e[e.Multiply=1]="Multiply",e[e.Add=2]="Add",e[e.SubTexture=3]="SubTexture"}(r||(r={}));class p extends o.y{_sphereTexture=null;_sphereTextureBlendMode=r.Add;_toonTexture=null;_ignoreDiffuseWhenToonTextureIsNull=!1;textureMultiplicativeColor=new a.ov(1,1,1,1);textureAdditiveColor=new a.ov(0,0,0,0);sphereTextureMultiplicativeColor=new a.ov(1,1,1,1);sphereTextureAdditiveColor=new a.ov(0,0,0,0);toonTextureMultiplicativeColor=new a.ov(1,1,1,1);toonTextureAdditiveColor=new a.ov(0,0,0,0);_applyAmbientColorToDiffuse=!0;_clampAlpha=!0;_useTextureColor=!1;_useSphereTextureColor=!1;_useToonTextureColor=!1;_isEnabled=!1;get isEnabled(){return this._isEnabled}set isEnabled(e){this._isEnabled!==e&&(this._isEnabled=e,this.markAllDefinesAsDirty(),this._enable(e))}get sphereTexture(){return this._sphereTexture}set sphereTexture(e){this._sphereTexture!==e&&(this._sphereTexture=e,this._markAllSubMeshesAsTexturesDirty())}get sphereTextureBlendMode(){return this._sphereTextureBlendMode}set sphereTextureBlendMode(e){this._sphereTextureBlendMode!==e&&(this._sphereTextureBlendMode=e,this.markAllDefinesAsDirty())}get toonTexture(){return this._toonTexture}set toonTexture(e){this._toonTexture!==e&&(this._toonTexture=e,this._markAllSubMeshesAsTexturesDirty())}get ignoreDiffuseWhenToonTextureIsNull(){return this._ignoreDiffuseWhenToonTextureIsNull}set ignoreDiffuseWhenToonTextureIsNull(e){this._ignoreDiffuseWhenToonTextureIsNull!==e&&(this._ignoreDiffuseWhenToonTextureIsNull=e,this.markAllDefinesAsDirty())}get applyAmbientColorToDiffuse(){return this._applyAmbientColorToDiffuse}set applyAmbientColorToDiffuse(e){this._applyAmbientColorToDiffuse!==e&&(this._applyAmbientColorToDiffuse=e,this.markAllDefinesAsDirty())}get clampAlpha(){return this._clampAlpha}set clampAlpha(e){this._clampAlpha!==e&&(this._clampAlpha=e,this.markAllDefinesAsDirty())}get useTextureColor(){return this._useTextureColor}set useTextureColor(e){this._useTextureColor!==e&&(this._useTextureColor=e,this.markAllDefinesAsDirty())}get useSphereTextureColor(){return this._useSphereTextureColor}set useSphereTextureColor(e){this._useSphereTextureColor!==e&&(this._useSphereTextureColor=e,this.markAllDefinesAsDirty())}get useToonTextureColor(){return this._useToonTextureColor}set useToonTextureColor(e){this._useToonTextureColor!==e&&(this._useToonTextureColor=e,this.markAllDefinesAsDirty())}_internalMarkAllSubMeshesAsTexturesDirty;_markAllSubMeshesAsTexturesDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}isCompatible(e){return!0}constructor(e,t=!0,n=!1,r=!1){super(e,"MmdMaterial",100,new u,t,n,r),this._internalMarkAllSubMeshesAsTexturesDirty=e._dirtyCallbacks[i.Y.MATERIAL_TextureDirtyFlag]}isReadyForSubMesh(e,t){return!this._isEnabled||!(e._areTexturesDirty&&t.texturesEnabled&&this._sphereTexture&&!this._sphereTexture.isReadyOrNotBlocking())}bindForSubMesh(e,t,n,r){if(!this._isEnabled)return;const i=r.materialDefines,s=this._material.isFrozen;e.useUbo&&s&&e.isSync||(i.DIFFUSE&&i.TEXTURE_COLOR&&(e.updateDirectColor4("textureMultiplicativeColor",this.textureMultiplicativeColor),e.updateDirectColor4("textureAdditiveColor",this.textureAdditiveColor)),i.NORMAL&&i.SPHERE_TEXTURE&&i.SPHERE_TEXTURE_COLOR&&(e.updateDirectColor4("sphereTextureMultiplicativeColor",this.sphereTextureMultiplicativeColor),e.updateDirectColor4("sphereTextureAdditiveColor",this.sphereTextureAdditiveColor)),i.TOON_TEXTURE&&i.TOON_TEXTURE_COLOR&&(e.updateDirectColor4("toonTextureMultiplicativeColor",this.toonTextureMultiplicativeColor),e.updateDirectColor4("toonTextureAdditiveColor",this.toonTextureAdditiveColor)),i.SPHERE_TEXTURE&&null!==r.effect&&this._material.bindView(r.effect)),t.texturesEnabled&&(i.NORMAL&&this._sphereTexture&&e.setTexture("sphereSampler",this._sphereTexture),this._toonTexture&&e.setTexture("toonSampler",this._toonTexture))}dispose(e){e&&(this._sphereTexture?.dispose(),this._toonTexture?.dispose())}prepareDefines(e,t,n){if(this._isEnabled){const i=t.texturesEnabled;e.SPHERE_TEXTURE=null!==this._sphereTexture&&i,e.SPHERE_TEXTURE_BLEND_MODE_MULTIPLY=this._sphereTextureBlendMode===r.Multiply,e.SPHERE_TEXTURE_BLEND_MODE_ADD=this._sphereTextureBlendMode===r.Add,e.TOON_TEXTURE=null!==this._toonTexture&&i,e.IGNORE_DIFFUSE_WHEN_TOON_TEXTURE_DISABLED=this._ignoreDiffuseWhenToonTextureIsNull,e.APPLY_AMBIENT_COLOR_TO_DIFFUSE=this._applyAmbientColorToDiffuse,e.CLAMP_ALPHA=this._clampAlpha,e.TEXTURE_COLOR=this._useTextureColor,e.SPHERE_TEXTURE_COLOR=this._useSphereTextureColor,e.TOON_TEXTURE_COLOR=this._useToonTextureColor,e.SDEF=n.useBones&&n.computeBonesUsingShaders&&!!n.skeleton&&n.isVerticesDataPresent(h.V.MatricesSdefCKind)}else e.SPHERE_TEXTURE=!1,e.SPHERE_TEXTURE_BLEND_MODE_MULTIPLY=!1,e.SPHERE_TEXTURE_BLEND_MODE_ADD=!1,e.TOON_TEXTURE=!1,e.IGNORE_DIFFUSE_WHEN_TOON_TEXTURE_DISABLED=!1,e.APPLY_AMBIENT_COLOR_TO_DIFFUSE=!1,e.CLAMP_ALPHA=!1,e.TEXTURE_COLOR=!1,e.SPHERE_TEXTURE_COLOR=!1,e.TOON_TEXTURE_COLOR=!1,e.SDEF=!1}hasTexture(e){return this._sphereTexture===e||this._toonTexture===e}getActiveTextures(e){this._sphereTexture&&e.push(this._sphereTexture),this._toonTexture&&e.push(this._toonTexture)}getAnimatables(e){this._sphereTexture&&this._sphereTexture.animations&&0<this._sphereTexture.animations.length&&e.push(this._sphereTexture),this._toonTexture&&this._toonTexture.animations&&0<this._toonTexture.animations.length&&e.push(this._toonTexture)}getSamplers(e){e.push("sphereSampler","toonSampler")}getAttributes(e,t,n){this._isEnabled&&n.useBones&&n.computeBonesUsingShaders&&n.skeleton&&n.isVerticesDataPresent(h.V.MatricesSdefCKind)&&(e.push(h.V.MatricesSdefCKind),e.push(h.V.MatricesSdefRW0Kind),e.push(h.V.MatricesSdefRW1Kind))}getUniforms(e){return{ubo:[{name:"textureMultiplicativeColor",size:4,type:"vec4"},{name:"textureAdditiveColor",size:4,type:"vec4"},{name:"sphereTextureMultiplicativeColor",size:4,type:"vec4"},{name:"sphereTextureAdditiveColor",size:4,type:"vec4"},{name:"toonTextureMultiplicativeColor",size:4,type:"vec4"},{name:"toonTextureAdditiveColor",size:4,type:"vec4"}]}}getClassName(){return"MmdPluginMaterial"}}c([(0,l.uM)("sphereTexture")],p.prototype,"_sphereTexture",void 0),c([(0,l.lK)("sphereTextureBlendMode")],p.prototype,"_sphereTextureBlendMode",void 0),c([(0,l.uM)("toonTexture")],p.prototype,"_toonTexture",void 0),c([(0,l.lK)("ignoreDiffuseWhenToonTextureIsNull")],p.prototype,"_ignoreDiffuseWhenToonTextureIsNull",void 0),c([(0,l.lK)("applyAmbientColorToDiffuse")],p.prototype,"_applyAmbientColorToDiffuse",void 0),c([(0,l.lK)("clampAlpha")],p.prototype,"_clampAlpha",void 0),(0,d.Y5)("BABYLON.MmdPluginMaterial",p)},8822:(e,t,n)=>{var r=n(3720);class i{_canvas;_engine;_scene;_onTick;constructor(e){this._canvas=e.canvas,this._engine=e.engine,this._scene=null,this._onTick=null}static async Create(e){const t=new i(e);return t._scene=await t._initialize(e.sceneBuilder),t._onTick=t._makeOnTick(),t}run(){const e=this._engine;window.addEventListener("resize",this._onResize),e.runRenderLoop(this._onTick)}dispose(){window.removeEventListener("resize",this._onResize),this._engine.dispose()}_onResize=()=>{this._engine.resize()};async _initialize(e){return await e.build(this._canvas,this._engine)}_makeOnTick(){const e=this._scene;return()=>e.render()}}n(9679),n(9400),n(994),n(1318);var s=n(5616),o=n(6125),a=n(492),l=n(5476),d=n(2565),h=n(467),c=n(5662),u=n(9923),p=n(554),g=n(6945),f=n(3036),m=n(9339),x=n(5041),y=n(7198),A=n(4122);class T{static OverrideEngineCreateEffect(e){const t=e.createEffect.bind(e);e.createEffect=function(e,n,r,i,s,o,a,l,d,h=c.w.GLSL,u){let p;if(p=n.attributes?n:{attributes:n,uniformsNames:r,uniformBuffersNames:[],samplers:i??[],defines:s??"",fallbacks:o??null,onCompiled:a??null,onError:l??null,indexParameters:d??null,shaderLanguage:h,extraInitializationsAsync:u},(p.uniformsNames.includes("mBones")||p.samplers.includes("boneSampler"))&&-1===p.defines.indexOf("#define SDEF")){p.attributes.push(f.V.MatricesSdefCKind),p.attributes.push(f.V.MatricesSdefRW0Kind),p.attributes.push(f.V.MatricesSdefRW1Kind),p.defines+="\n#define SDEF";const e=p.processCodeAfterIncludes;p.processCodeAfterIncludes=e?function(t,n){return n=e(t,n),T.ProcessSdefCode(t,n)}:T.ProcessSdefCode}return t(e,p,this)}}static ProcessSdefCode(e,t){if("vertex"!==e)return t;if(t.includes("finalWorld=finalWorld*influence;")){const e=t.includes("fn main"),n="#define CUSTOM_VERTEX_DEFINITIONS";if(t.includes(n))t=t.replace(n,`${n}\n${e?y.B:m.B}`);else{const n="void main() {";t=t.replace(n,`${e?y.B:m.B}\nvoid main() {`)}const r=new RegExp("finalWorld=finalWorld\\*influence;","g");t=t.replace(r,`${e?A.Z:x.Z}\nfinalWorld=finalWorld*influence;`)}return t}}p.Z.prototype.getMmdOutlineRenderer=function(){return this._mmdOutlineRenderer||(this._mmdOutlineRenderer=new M(this)),this._mmdOutlineRenderer};class M{name="MmdOutline";scene;zOffset=4;zOffsetUnits=0;_engine;_passIdForDrawWrapper;constructor(e){this.scene=e,this._engine=e.getEngine(),this.scene._addComponent(this),this._passIdForDrawWrapper=this._engine.createRenderPassId("Mmd Outline Renderer")}register(){this.scene._afterRenderingMeshStage.registerStep(g.v.STEP_AFTERRENDERINGMESH_OUTLINE,this,this._afterRenderingMesh)}rebuild(){}dispose(){this._engine.releaseRenderPassId(this._passIdForDrawWrapper)}static _ViewMatrix=new Float32Array(9);static _InverseViewProjectionMatrix=new u.uq;render(e,t,n){n=n??this._passIdForDrawWrapper;const r=this.scene,i=r.getEngine(),s=i.getCaps().instancedArrays&&(null!==t.visibleInstances[e._id]&&void 0!==t.visibleInstances[e._id]||e.getRenderingMesh().hasThinInstances);if(!this.isReady(e,s,n))return;const o=e.getMesh(),d=o._internalAbstractMeshDataInfo._actAsRegularMesh?o:null,c=e.getRenderingMesh(),u=d||c,p=e.getMaterial();if(!p||!r.activeCamera)return;const g=e._getDrawWrapper(n),f=l.E.GetEffect(g);i.enableEffect(g),p.useLogarithmicDepth&&f.setFloat("logarithmicDepthConstant",2/(Math.log(r.activeCamera.maxZ+1)/Math.LN2)),f.setFloat("offset",p.outlineWidth),f.setColor4("color",p.outlineColor,p.outlineAlpha);const m=i.getRenderHeight(),x=i.getRenderWidth();f.setFloat2("viewport",x,m);const y=M._ViewMatrix;{const e=r.getViewMatrix().m;y[0]=e[0],y[1]=e[1],y[2]=e[2],y[3]=e[4],y[4]=e[5],y[5]=e[6],y[6]=e[8],y[7]=e[9],y[8]=e[10]}f.setMatrix3x3("view",y),f.setMatrix("viewProjection",r.getTransformMatrix()),f.setMatrix("world",u.getWorldMatrix()),(0,h.f$)(c,f),(0,h.nR)(c,f),c.morphTargetManager&&c.morphTargetManager.isUsingTextureForTargets&&c.morphTargetManager._bind(f),s||c._bind(e,f,p.fillMode);const A=e.getMesh().bakedVertexAnimationManager;if(A&&A.isEnabled&&A.bind(f,s),p&&p.needAlphaTesting()){const e=p.getAlphaTestTexture();e&&(f.setTexture("diffuseSampler",e),f.setMatrix("diffuseMatrix",e.getTextureMatrix()))}(0,a.gS)(f,p,r),f.defines.includes("WORLDPOS_REQUIRED")&&f.setMatrix("inverseViewProjection",r.getTransformMatrix().invertToRef(M._InverseViewProjectionMatrix)),i.setZOffset(this.zOffset),i.setZOffsetUnits(this.zOffsetUnits),c._processRendering(u,e,f,p.fillMode,t,s,((e,t)=>{f.setMatrix("world",t)})),i.setZOffset(0),i.setZOffsetUnits(0)}isReady(e,t,r){r=r??this._passIdForDrawWrapper;const i=[],o=[s.R.PositionKind,s.R.NormalKind],l=e.getMesh(),u=e.getMaterial();if(!u)return!1;const p=l.getScene();u.needAlphaTesting()&&(i.push("#define ALPHATEST"),l.isVerticesDataPresent(s.R.UVKind)&&(o.push(s.R.UVKind),i.push("#define UV1")),l.isVerticesDataPresent(s.R.UV2Kind)&&(o.push(s.R.UV2Kind),i.push("#define UV2"))),u.useLogarithmicDepth&&i.push("#define LOGARITHMICDEPTH"),(0,a.tv)(u,p,i);let g=!1;for(let e=0;e<i.length;++e)if(i[e].includes("CLIPPLANE")){g=!0;break}g&&i.push("#define WORLDPOS_REQUIRED");const m=new d.J;if(l.useBones&&l.computeBonesUsingShaders&&l.skeleton){o.push(s.R.MatricesIndicesKind),o.push(s.R.MatricesWeightsKind),l.numBoneInfluencers>4&&(o.push(s.R.MatricesIndicesExtraKind),o.push(s.R.MatricesWeightsExtraKind)),l.isVerticesDataPresent(f.V.MatricesSdefCKind)&&(o.push(f.V.MatricesSdefCKind),o.push(f.V.MatricesSdefRW0Kind),o.push(f.V.MatricesSdefRW1Kind),i.push("#define SDEF"));const e=l.skeleton;i.push("#define NUM_BONE_INFLUENCERS "+l.numBoneInfluencers),l.numBoneInfluencers>0&&m.addCPUSkinningFallback(0,l),e.isUsingTextureForMatrices?i.push("#define BONETEXTURE"):i.push("#define BonesPerMesh "+(e.bones.length+1))}else i.push("#define NUM_BONE_INFLUENCERS 0");const x=l.morphTargetManager;let y=0;x&&(y=x.numMaxInfluencers||x.numInfluencers,y>0&&(i.push("#define MORPHTARGETS"),i.push("#define NUM_MORPH_INFLUENCERS "+y),x.isUsingTextureForTargets&&i.push("#define MORPHTARGETS_TEXTURE"),(0,h.MF)(o,l,y))),t&&(i.push("#define INSTANCES"),(0,h.te)(o),e.getRenderingMesh().hasThinInstances&&i.push("#define THIN_INSTANCES"));const A=l.bakedVertexAnimationManager;A&&A.isEnabled&&(i.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),t&&o.push("bakedVertexAnimationSettingsInstanced"));const M=e._getDrawWrapper(r,!0),_=M.defines,b=i.join("\n");if(_!==b){const e=["world","mBones","viewport","view","viewProjection","diffuseMatrix","offset","color","logarithmicDepthConstant","morphTargetInfluences","boneTextureWidth","morphTargetCount","morphTargetTextureInfo","morphTargetTextureIndices","bakedVertexAnimationSettings","bakedVertexAnimationTextureSizeInverted","bakedVertexAnimationTime","bakedVertexAnimationTexture"],t=["diffuseSampler","boneSampler","morphTargets","bakedVertexAnimationTexture"];(0,a.TV)(e),g&&e.push("inverseViewProjection");const r=p.getEngine().isWebGPU?c.w.WGSL:c.w.GLSL;M.setEffect(this.scene.getEngine().createEffect("mmdOutline",{attributes:o,uniformsNames:e,uniformBuffersNames:[],samplers:t,defines:b,fallbacks:m,onCompiled:null,onError:null,indexParameters:{maxSimultaneousMorphTargets:y},processCodeAfterIncludes:T.ProcessSdefCode,shaderLanguage:r,extraInitializationsAsync:async()=>{r===c.w.WGSL?await Promise.all([n.e(126).then(n.bind(n,8980)),n.e(126).then(n.bind(n,1870))]):await Promise.all([n.e(71).then(n.bind(n,3357)),n.e(71).then(n.bind(n,5043))])}},this.scene.getEngine()),b)}return M.effect.isReady()}_afterRenderingMesh(e,t,n){const r=t.getMaterial();if(null!==r&&r.renderOutline){const e=this._engine,r=e.getDepthWrite(),i=e.getAlphaMode(),s=e.alphaState.alphaBlend;e.setDepthWrite(!0),e.setAlphaMode(o.Y.ALPHA_COMBINE,!0),e.setState(!0,void 0,void 0,void 0,!!this.scene._mirroredCameraPosition),this.render(t,n,this._passIdForDrawWrapper),e.setAlphaMode(i,!0),e.setDepthWrite(r),e.alphaState.alphaBlend=s}}}var _,b,I=n(5909);class v{log(e){console.log(e)}warn(e){console.warn(e)}error(e){console.error(e)}}class w{isDeviceLittleEndian;_dataView;_decoder;_offset;constructor(e){this.isDeviceLittleEndian=this._getIsDeviceLittleEndian(),this._dataView=new DataView(e),this._decoder=null,this._offset=0}get offset(){return this._offset}set offset(e){this._offset=e}_getIsDeviceLittleEndian(){const e=new Int16Array([256]);return 1===new Int8Array(e.buffer)[1]}swap16Array(e){for(let t=0;t<e.length;++t){const n=e[t];e[t]=(255&n)<<8|n>>8&255}}swap32Array(e){for(let t=0;t<e.length;++t){const n=e[t];e[t]=(255&n)<<24|(65280&n)<<8|n>>8&65280|n>>24&255}}getUint8(){const e=this._dataView.getUint8(this._offset);return this._offset+=1,e}getInt8(){const e=this._dataView.getInt8(this._offset);return this._offset+=1,e}getUint8Array(e){const t=new Uint8Array(this._dataView.buffer,this._offset,e.byteLength);e.set(t),this._offset+=e.byteLength}getUint16(){const e=this._dataView.getUint16(this._offset,!0);return this._offset+=2,e}getUint16Array(e){const t=new Uint8Array(this._dataView.buffer,this._offset,e.byteLength);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(t),this._offset+=e.byteLength,this.isDeviceLittleEndian||this.swap16Array(e)}getInt16(){const e=this._dataView.getInt16(this._offset,!0);return this._offset+=2,e}getUint32(){const e=this._dataView.getUint32(this._offset,!0);return this._offset+=4,e}getUint32Array(e){const t=new Uint8Array(this._dataView.buffer,this._offset,e.byteLength);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(t),this._offset+=e.byteLength,this.isDeviceLittleEndian||this.swap32Array(e)}getInt32(){const e=this._dataView.getInt32(this._offset,!0);return this._offset+=4,e}getInt32Array(e){const t=new Uint8Array(this._dataView.buffer,this._offset,e.byteLength);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(t),this._offset+=e.byteLength,this.isDeviceLittleEndian||this.swap32Array(e)}getFloat32(){const e=this._dataView.getFloat32(this._offset,!0);return this._offset+=4,e}getFloat32Array(e){const t=new Uint8Array(this._dataView.buffer,this._offset,e.byteLength);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(t),this._offset+=e.byteLength,this.isDeviceLittleEndian||this.swap32Array(e)}getFloat32Tuple(e){const t=new Array(e);for(let n=0;n<e;++n)t[n]=this._dataView.getFloat32(this._offset,!0),this._offset+=4;return t}initializeTextDecoder(e){this._decoder=new TextDecoder(e)}getDecoderString(e,t){if(null===this._decoder)throw new Error("TextDecoder is not initialized.");let n=new Uint8Array(this._dataView.buffer,this._offset,e);if(this._offset+=e,t)for(let e=0;e<n.length;++e)if(0===n[e]){n=n.subarray(0,e);break}return this._decoder.decode(n)}getSignatureString(e){const t=new TextDecoder("utf-8"),n=new Uint8Array(this._dataView.buffer,this._offset,e);return this._offset+=e,t.decode(n)}getPaddedArrayOffset(e,t){this._offset+=this._offset%e==0?0:e-this._offset%e;const n=this._offset;return this._offset+=e*t,n}get bytesAvailable(){return this._dataView.byteLength-this._offset}}!function(e){let t;!function(e){let t;!function(e){e[e.Rotate=0]="Rotate",e[e.RotateMove=1]="RotateMove",e[e.Ik=2]="Ik",e[e.Unknown=3]="Unknown",e[e.IkLink=4]="IkLink",e[e.RotateEffect=5]="RotateEffect",e[e.IkTo=6]="IkTo",e[e.Invisible=7]="Invisible",e[e.Twist=8]="Twist",e[e.RotateRatio=9]="RotateRatio"}(t=e.Type||(e.Type={}))}(t=e.Bone||(e.Bone={}))}(_||(_={})),function(e){let t,n,r,i,s,o,a,l,d;!function(e){let t;!function(e){e[e.Utf16le=0]="Utf16le",e[e.Utf8=1]="Utf8",e[e.ShiftJis=2]="ShiftJis"}(t=e.Encoding||(e.Encoding={}))}(t=e.Header||(e.Header={})),function(e){let t;!function(e){e[e.Bdef1=0]="Bdef1",e[e.Bdef2=1]="Bdef2",e[e.Bdef4=2]="Bdef4",e[e.Sdef=3]="Sdef",e[e.Qdef=4]="Qdef"}(t=e.BoneWeightType||(e.BoneWeightType={}))}(n=e.Vertex||(e.Vertex={})),function(e){let t,n;!function(e){e[e.IsDoubleSided=1]="IsDoubleSided",e[e.EnabledGroundShadow=2]="EnabledGroundShadow",e[e.EnabledDrawShadow=4]="EnabledDrawShadow",e[e.EnabledReceiveShadow=8]="EnabledReceiveShadow",e[e.EnabledToonEdge=16]="EnabledToonEdge",e[e.EnabledVertexColor=32]="EnabledVertexColor",e[e.EnabledPointDraw=64]="EnabledPointDraw",e[e.EnabledLineDraw=128]="EnabledLineDraw"}(t=e.Flag||(e.Flag={})),function(e){e[e.Off=0]="Off",e[e.Multiply=1]="Multiply",e[e.Add=2]="Add",e[e.SubTexture=3]="SubTexture"}(n=e.SphereTextureMode||(e.SphereTextureMode={}))}(r=e.Material||(e.Material={})),function(e){let t;!function(e){e[e.UseBoneIndexAsTailPosition=1]="UseBoneIndexAsTailPosition",e[e.IsRotatable=2]="IsRotatable",e[e.IsMovable=4]="IsMovable",e[e.IsVisible=8]="IsVisible",e[e.IsControllable=16]="IsControllable",e[e.IsIkEnabled=32]="IsIkEnabled",e[e.LocalAppendTransform=128]="LocalAppendTransform",e[e.HasAppendRotate=256]="HasAppendRotate",e[e.HasAppendMove=512]="HasAppendMove",e[e.HasAxisLimit=1024]="HasAxisLimit",e[e.HasLocalVector=2048]="HasLocalVector",e[e.TransformAfterPhysics=4096]="TransformAfterPhysics",e[e.IsExternalParentTransformed=8192]="IsExternalParentTransformed"}(t=e.Flag||(e.Flag={}))}(i=e.Bone||(e.Bone={})),function(e){let t,n,r;!function(e){e[e.System=0]="System",e[e.Eyebrow=1]="Eyebrow",e[e.Eye=2]="Eye",e[e.Lip=3]="Lip",e[e.Other=4]="Other"}(t=e.Category||(e.Category={})),function(e){e[e.GroupMorph=0]="GroupMorph",e[e.VertexMorph=1]="VertexMorph",e[e.BoneMorph=2]="BoneMorph",e[e.UvMorph=3]="UvMorph",e[e.AdditionalUvMorph1=4]="AdditionalUvMorph1",e[e.AdditionalUvMorph2=5]="AdditionalUvMorph2",e[e.AdditionalUvMorph3=6]="AdditionalUvMorph3",e[e.AdditionalUvMorph4=7]="AdditionalUvMorph4",e[e.MaterialMorph=8]="MaterialMorph",e[e.FlipMorph=9]="FlipMorph",e[e.ImpulseMorph=10]="ImpulseMorph"}(n=e.Type||(e.Type={})),function(e){let t;!function(e){e[e.Multiply=0]="Multiply",e[e.Add=1]="Add"}(t=e.Type||(e.Type={}))}(r=e.MaterialMorph||(e.MaterialMorph={}))}(s=e.Morph||(e.Morph={})),function(e){let t;!function(e){let t;!function(e){e[e.Bone=0]="Bone",e[e.Morph=1]="Morph"}(t=e.FrameType||(e.FrameType={}))}(t=e.FrameData||(e.FrameData={}))}(o=e.DisplayFrame||(e.DisplayFrame={})),function(e){let t,n;!function(e){e[e.Sphere=0]="Sphere",e[e.Box=1]="Box",e[e.Capsule=2]="Capsule"}(t=e.ShapeType||(e.ShapeType={})),function(e){e[e.FollowBone=0]="FollowBone",e[e.Physics=1]="Physics",e[e.PhysicsWithBone=2]="PhysicsWithBone"}(n=e.PhysicsMode||(e.PhysicsMode={}))}(a=e.RigidBody||(e.RigidBody={})),function(e){let t;!function(e){e[e.Spring6dof=0]="Spring6dof",e[e.Sixdof=1]="Sixdof",e[e.P2p=2]="P2p",e[e.ConeTwist=3]="ConeTwist",e[e.Slider=4]="Slider",e[e.Hinge=5]="Hinge"}(t=e.Type||(e.Type={}))}(l=e.Joint||(e.Joint={})),function(e){let t,n,r;!function(e){e[e.TriMesh=0]="TriMesh",e[e.Rope=1]="Rope"}(t=e.Type||(e.Type={})),function(e){e[e.Blink=1]="Blink",e[e.ClusterCreation=2]="ClusterCreation",e[e.LinkCrossing=4]="LinkCrossing"}(n=e.Flag||(e.Flag={})),function(e){e[e.VertexPoint=0]="VertexPoint",e[e.VertexTwoSided=1]="VertexTwoSided",e[e.VertexOneSided=2]="VertexOneSided",e[e.FaceTwoSided=3]="FaceTwoSided",e[e.FaceOneSided=4]="FaceOneSided"}(r=e.AeroDynamicModel||(e.AeroDynamicModel={}))}(d=e.SoftBody||(e.SoftBody={}))}(b||(b={}));class E{constructor(){}static async ParseAsync(e,t=new v){const n=new w(e);n.initializeTextDecoder("shift-jis");const r=this._ParseHeader(n),i=await this._ParseVerticesAsync(n),s=this._ParseIndices(n),o=this._ParseMaterials(n),a=this._ParseBones(n),l=this._ParseIks(n),d=this._ParseMorphs(n),[h,c]=this._ParseDisplayFrames(n,d);if(0===n.bytesAvailable){const e=[];return{header:r,vertices:i,indices:s,textures:e,materials:this._ConvertMaterials(o,e),bones:this._ConvertBones(a,l,i,h),morphs:d,displayFrames:h,rigidBodies:[],joints:[],softBodies:[]}}0!==n.getUint8()&&this._ParseEnglishNames(n,r,a,d,h,c);const u=this._ParseToonTextures(n),p=this._ConvertMaterials(o,u);if(0===n.bytesAvailable)return{header:r,vertices:i,indices:s,textures:u,materials:p,bones:this._ConvertBones(a,l,i,h),morphs:d,displayFrames:h,rigidBodies:[],joints:[],softBodies:[]};const g=this._ParseRigidBodies(n),f=this._ConvertBones(a,l,i,h,g);this._NormalizeRigidBodyPositions(g,f);const m=this._ParseJoints(n);return n.bytesAvailable>0&&t.warn(`There are ${n.bytesAvailable} bytes left after parsing`),{header:r,vertices:i,indices:s,textures:u,materials:p,bones:f,morphs:d,displayFrames:h,rigidBodies:g,joints:m,softBodies:[]}}static _ParseHeader(e){if(e.bytesAvailable<7)throw new Error("is not pmd file");const t=e.getSignatureString(3);if("Pmd"!==t)throw new Error("is not pmd file");const n=e.getFloat32(),r=e.getDecoderString(20,!0),i=e.getDecoderString(256,!0);return{signature:t,version:n,encoding:b.Header.Encoding.ShiftJis,additionalVec4Count:0,vertexIndexSize:2,textureIndexSize:4,materialIndexSize:4,boneIndexSize:2,morphIndexSize:2,rigidBodyIndexSize:4,modelName:r,englishModelName:"",comment:i,englishComment:""}}static async _ParseVerticesAsync(e){const t=e.getUint32(),n=[];let r=performance.now();for(let i=0;i<t;++i){const t=e.getFloat32Tuple(3),s=e.getFloat32Tuple(3),o=e.getFloat32Tuple(2),a=b.Vertex.BoneWeightType.Bdef2,l={boneIndices:[e.getUint16(),e.getUint16()],boneWeights:e.getUint8()/100},d=0!==e.getUint8();n.push({position:t,normal:s,uv:o,additionalVec4:[],weightType:a,boneWeight:l,edgeScale:d?1:0}),i%1e4==0&&100<performance.now()-r&&(await new Promise((e=>setTimeout(e,0))),r=performance.now())}return n}static _ParseIndices(e){const t=e.getUint32(),n=new Uint16Array(t);return e.getUint16Array(n),n}static _ParseMaterials(e){const t=e.getUint32(),n=[];for(let r=0;r<t;++r){const t=e.getFloat32Tuple(4),r=e.getFloat32(),i=e.getFloat32Tuple(3),s=e.getFloat32Tuple(3),o=e.getInt8(),a=e.getUint8(),l=e.getUint32(),d=e.getDecoderString(20,!0);let h=0;0!==a&&(h|=b.Material.Flag.EnabledToonEdge|b.Material.Flag.EnabledGroundShadow),.98!==t[3]&&(h|=b.Material.Flag.EnabledDrawShadow|b.Material.Flag.EnabledReceiveShadow),t[3]<1&&(h|=b.Material.Flag.IsDoubleSided);let c=b.Material.SphereTextureMode.Off,u="",p="";{const e=d.split("*");for(let t=0;t<e.length;++t){const n=e[t];let r=b.Material.SphereTextureMode.Off;if(""!==n){const e=n.lastIndexOf("."),t=-1!==e?n.substring(e).toLowerCase():"";".sph"===t?r=b.Material.SphereTextureMode.Multiply:".spa"===t&&(r=b.Material.SphereTextureMode.Add)}r!==b.Material.SphereTextureMode.Off?(c=r,p=n):u=n}}const g={name:d,englishName:"",diffuse:t,specular:i,shininess:r,ambient:s,flag:h,edgeColor:[0,0,0,1],edgeSize:1,textureIndex:u,sphereTextureIndex:p,sphereTextureMode:c,isSharedToonTexture:!1,toonTextureIndex:o,comment:"",indexCount:l};n.push(g)}return n}static _ParseBones(e){const t=e.getUint16(),n=[];for(let r=0;r<t;++r){const t={name:e.getDecoderString(20,!0),englishName:"",parentBoneIndex:e.getInt16(),tailIndex:e.getInt16(),type:e.getUint8(),ikIndex:e.getInt16(),position:e.getFloat32Tuple(3)};n.push(t)}return n}static _ParseIks(e){const t=e.getUint16(),n=[];for(let r=0;r<t;++r){const t=e.getUint16(),r=e.getUint16(),i=e.getUint8(),s=e.getUint16(),o=e.getFloat32(),a=[];for(let t=0;t<i;++t)a.push(e.getUint16());const l={boneIndex:t,targetIndex:r,iteration:s,rotationConstraint:o,links:a};n.push(l)}return n}static _ParseMorphs(e){const t=e.getUint16();if(0===t)return[];const n=[];for(let r=0;r<t;++r){const t=e.getDecoderString(20,!0),r=e.getUint32();let i={name:t,englishName:"",category:e.getUint8(),type:b.Morph.Type.VertexMorph};const s=new Int32Array(r),o=new Float32Array(3*r);for(let t=0;t<r;++t)s[t]=e.getUint32(),o[3*t+0]=e.getFloat32(),o[3*t+1]=e.getFloat32(),o[3*t+2]=e.getFloat32();i={...i,indices:s,positions:o},n.push(i)}const r=n.shift().indices;for(let e=0;e<n.length;++e){const t=n[e].indices;for(let e=0;e<t.length;++e){const n=t[e];0<=n&&n<r.length?t[e]=r[n]:t[e]=0}}return n}static _ParseDisplayFrames(e,t){const n=[],r=e.getUint8();for(let i=0;i<r;++i){const r={type:b.DisplayFrame.FrameData.FrameType.Morph,index:e.getUint16()},i={name:t[r.index]?.name??"",englishName:"",isSpecialFrame:!0,frames:[r]};n.push(i)}const i=n.length,s=e.getUint8();for(let t=0;t<s;++t){const t={name:e.getDecoderString(50,!0),englishName:"",isSpecialFrame:!1,frames:void 0};n.push(t)}const o=e.getUint32();for(let t=0;t<o;++t){const t=e.getUint16(),r=n[i+e.getUint8()-1];if(void 0!==r){const e={type:b.DisplayFrame.FrameData.FrameType.Bone,index:t};void 0===r.frames?r.frames=[e]:r.frames.push(e)}}for(let e=i;e<n.length;++e){const t=n[e];void 0===t.frames&&(t.frames=[])}return[n,i]}static _ParseEnglishNames(e,t,n,r,i,s){t.englishModelName=e.getDecoderString(20,!0),t.englishComment=e.getDecoderString(256,!0);for(let t=0;t<n.length;++t)n[t].englishName=e.getDecoderString(20,!0);for(let t=0;t<r.length;++t)r[t].englishName=e.getDecoderString(20,!0);for(let t=s;t<i.length;++t)i[t].englishName=e.getDecoderString(50,!0)}static _ParseToonTextures(e){const t=[];for(let n=0;n<10;++n)t.push(e.getDecoderString(100,!0));return t}static _PathNormalize(e){const t=(e=e.replace(/\\/g,"/")).split("/"),n=[];for(let e=0;e<t.length;++e){const r=t[e];"."!==r&&(".."===r?n.pop():n.push(r))}return n.join("/").toLowerCase()}static _ConvertMaterials(e,t){const n=new Array(t.length);for(let e=0;e<t.length;++e)n[e]=this._PathNormalize(t[e]);for(let r=0;r<e.length;++r){const i=e[r];if(0<=i.toonTextureIndex&&i.toonTextureIndex<t.length){const e=n[i.toonTextureIndex];if(/toon(10|0[0-9])\.bmp/.test(e)){i.isSharedToonTexture=!0;let t=e.substring(e.length-6,e.length-4);"n"===t[0]&&(t=t[1]),i.toonTextureIndex=parseInt(t,10)-1}}}const r=new Map;for(let e=0;e<t.length;++e)r.set(this._PathNormalize(t[e]),e);for(let n=0;n<e.length;++n){const i=e[n];if(""!==i.textureIndex){const e=this._PathNormalize(i.textureIndex);let n=r.get(e);void 0===n&&(n=r.size,r.set(e,n),t.push(i.textureIndex)),i.textureIndex=n}else i.textureIndex=-1;if(""!==i.sphereTextureIndex){const e=this._PathNormalize(i.sphereTextureIndex);let n=r.get(e);void 0===n&&(n=r.size,r.set(e,n),t.push(i.sphereTextureIndex)),i.sphereTextureIndex=n}else i.sphereTextureIndex=-1}return e}static _IkAngleLimitTable=new Map(Object.entries({左ひざ:[-180,-.5,0,0,0,0],右ひざ:[-180,-.5,0,0,0,0]}));static _ConvertBones(e,t,n,r,i){const s=new Map;for(let n=0;n<t.length;++n){const r=t[n].boneIndex;0<=r&&r<e.length&&!s.has(r)&&s.set(r,n)}const o=[];for(let t=0;t<e.length;++t){const n=e[t],r={name:n.name,englishName:n.englishName,position:n.position,parentBoneIndex:n.parentBoneIndex,transformOrder:0,flag:b.Bone.Flag.UseBoneIndexAsTailPosition,tailPosition:n.tailIndex<=0?-1:n.tailIndex,appendTransform:void 0,axisLimit:void 0,localVector:void 0,externalParentTransform:void 0,ik:void 0};let i=s.has(t);switch(r.flag|=b.Bone.Flag.IsRotatable|b.Bone.Flag.IsVisible|b.Bone.Flag.IsControllable,r.flag&=~b.Bone.Flag.IsMovable&~b.Bone.Flag.IsIkEnabled&~b.Bone.Flag.HasAppendRotate&~b.Bone.Flag.HasAxisLimit,n.type){case _.Bone.Type.RotateMove:r.flag|=b.Bone.Flag.IsMovable;break;case _.Bone.Type.Ik:i=!0;break;case _.Bone.Type.RotateEffect:r.flag|=b.Bone.Flag.HasAppendRotate,r.flag&=~b.Bone.Flag.UseBoneIndexAsTailPosition&~b.Bone.Flag.IsVisible,r.appendTransform={parentIndex:n.tailIndex,ratio:.01*n.ikIndex}}i&&(r.flag|=b.Bone.Flag.IsMovable|b.Bone.Flag.IsIkEnabled,r.transformOrder=1),o.push(r)}let a=Math.min(o.length,e.length);for(let t=0;t<a;++t){const n=e[t],r=o[t];if(n.type===_.Bone.Type.Twist){let t=e[n.tailIndex];void 0===t&&(t=e[0]);const i=t.position,s=n.position;r.axisLimit=[i[0]-s[0],i[1]-s[1],i[2]-s[2]];const o=r.axisLimit,a=Math.sqrt(o[0]*o[0]+o[1]*o[1]+o[2]*o[2]);o[0]/=a,o[1]/=a,o[2]/=a,r.flag&=~b.Bone.Flag.UseBoneIndexAsTailPosition}}const l=[];for(let n=0;n<a;++n){const r=o[n];if(0==(r.flag&b.Bone.Flag.IsIkEnabled))continue;let i=0;for(let s=0;s<t.length;++s){const a=t[s];if(a.boneIndex!==n)continue;let d;0===i?(d=r,i+=1):(d={name:r.name+"+",englishName:r.englishName,position:[...r.position],parentBoneIndex:n,transformOrder:r.transformOrder,flag:r.flag&~b.Bone.Flag.IsVisible&~b.Bone.Flag.UseBoneIndexAsTailPosition,tailPosition:[0,0,0],appendTransform:void 0!==r.appendTransform?{...r.appendTransform}:void 0,axisLimit:void 0!==r.axisLimit?[...r.axisLimit]:void 0,localVector:void 0!==r.localVector?{x:[...r.localVector.x],z:[...r.localVector.z]}:void 0,externalParentTransform:r.externalParentTransform,ik:void 0},l.push(d),i+=1),void 0===d.ik&&(d.ik={target:0,iteration:0,rotationConstraint:0,links:[]});{const t=d.ik;t.target=a.targetIndex,t.iteration=a.iteration,t.rotationConstraint=4*a.rotationConstraint;const n=a.links;for(let r=0;r<n.length;++r){const i=n[r];if(0<=i&&i<o.length){const n={target:i,limitation:void 0};if(0<=i&&i<e.length){const t=e[i].name,r=this._IkAngleLimitTable.get(t);void 0!==r&&(n.limitation={minimumAngle:[r[0],r[2],r[4]],maximumAngle:[r[1],r[3],r[5]]})}t.links.push(n)}}}}}o.push(...l),a=Math.min(o.length,e.length);const d=[];for(let e=0;e<a;++e)if(0!=(o[e].flag&b.Bone.Flag.IsIkEnabled))for(let n=0;n<t.length;++n)if(t[n].boneIndex===e){d.push([e,n]);break}let h=!0;for(let e=0;e<d.length-1;++e)if(d[e][1]>d[e+1][1]){h=!1;break}if(!h){d.sort(((e,t)=>e[1]-t[1]));const e=new Array(d.length);for(let t=1;t<d.length;++t){let n=!0;(d[t-1][0]>d[t][0]||void 0!==e[t-1])&&(n=!1),n||(e[t]=o[d[t-1][0]])}const t=new Map;for(let n=0;n<e.length;++n){const r=e[n];void 0===r||t.has(r)||t.set(r,n)}const s=new Array(d.length);for(let e=0;e<d.length;++e)s[e]=o[d[e][0]];const a=o.slice();for(let n=0;0<t.size;++n){for(let n=1;n<d.length;++n)if(void 0!==e[n]&&void 0!==s[n]&&!t.has(s[n])){const r=s[n],i=o.indexOf(r);o.splice(i,1);const a=o.indexOf(e[n])+1;o.splice(a,0,r),t.delete(r)}if(d.length<n)break}const l=new Map;for(let e=0;e<o.length;++e){const t=o[e];l.set(t,e)}for(let e=0;e<n.length;++e){const t=n[e].boneWeight;if("number"==typeof t.boneIndices)t.boneIndices=l.get(a[t.boneIndices]);else{const e=t.boneIndices;for(let t=0;t<e.length;++t)e[t]=l.get(a[e[t]])}}for(let e=0;e<o.length;++e){const t=o[e];if(t.parentBoneIndex=l.get(a[t.parentBoneIndex]),"number"==typeof t.tailPosition&&(t.tailPosition=l.get(a[t.tailPosition])),t.appendTransform&&(t.appendTransform.parentIndex=l.get(a[t.appendTransform.parentIndex])),t.ik){t.ik.target=l.get(a[t.ik.target]);const e=t.ik.links;for(let t=0;t<e.length;++t)e[t].target=l.get(a[e[t].target])}}for(let e=0;e<r.length;++e){const t=r[e].frames;if(void 0!==t)for(let e=0;e<t.length;++e){const n=t[e];n.type===b.DisplayFrame.FrameData.FrameType.Bone&&(n.index=l.get(a[n.index]))}}if(void 0!==i)for(let e=0;e<i.length;++e){const t=i[e];t.boneIndex=l.get(a[t.boneIndex])}}let c=!1;for(let e=0;e<o.length;++e){let t=o[e];for(let n=0;n<o.length;++n){const r=o[n].parentBoneIndex;if(r===e){c=!0;break}if(t=o[r],void 0===t)break}if(c)break}if(c)for(let e=0;e<o.length;++e){let e=!1;for(let t=0;t<o.length;++t){const n=o[t];let r=n,i=n.transformOrder;for(;;){const t=o[r.parentBoneIndex];if(void 0===t)break;i<t.transformOrder&&(i=t.transformOrder,e=!0),r=t}n.transformOrder=i}if(!e)break}for(let e=0;e<o.length;++e){const t=o[e];0!=(t.flag&b.Bone.Flag.UseBoneIndexAsTailPosition)?"number"!=typeof t.tailPosition&&(t.tailPosition=-1):"number"==typeof t.tailPosition&&(t.tailPosition=[0,0,0])}return o}static _ParseRigidBodies(e){const t=e.getUint32(),n=[];for(let r=0;r<t;++r){const t={name:e.getDecoderString(20,!0),englishName:"",boneIndex:e.getInt16(),collisionGroup:e.getUint8(),collisionMask:e.getUint16(),shapeType:e.getUint8(),shapeSize:e.getFloat32Tuple(3),shapePosition:e.getFloat32Tuple(3),shapeRotation:e.getFloat32Tuple(3),mass:e.getFloat32(),linearDamping:e.getFloat32(),angularDamping:e.getFloat32(),repulsion:e.getFloat32(),friction:e.getFloat32(),physicsMode:e.getUint8()};n.push(t)}return n}static _NormalizeRigidBodyPositions(e,t){for(let n=0;n<e.length;++n){const r=e[n],i=t[r.boneIndex<0?0:r.boneIndex].position,s=r.shapePosition;s[0]+=i[0],s[1]+=i[1],s[2]+=i[2]}}static _ParseJoints(e){const t=e.getUint32(),n=[];for(let r=0;r<t;++r){const t=e.getDecoderString(20,!0),r=e.getInt32(),i=e.getInt32(),s=e.getFloat32Tuple(3),o=e.getFloat32Tuple(3),a=e.getFloat32Tuple(3),l=e.getFloat32Tuple(3),d=e.getFloat32Tuple(3),h=e.getFloat32Tuple(3),c=e.getFloat32Tuple(3),u=e.getFloat32Tuple(3),p={name:t,englishName:"",type:b.Joint.Type.Spring6dof,rigidbodyIndexA:r,rigidbodyIndexB:i,position:s,rotation:o,positionMin:a,positionMax:l,rotationMin:d,rotationMax:h,springPosition:c,springRotation:u};n.push(p)}return n}}const S={".pmd":{isBinary:!0}};var C=n(1359),F=n(5530),B=n(6803),R=n(998),U=n(706),D=n(216),P=n(7762),k=n(6504),V=n(3346),L=n(2564),O=n(1137),N=n(8986),z=n(6041),W=n(2781),q=n(9848),K=n(2940);class H{static Data=["data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII="]}function G(e){const t=(e=e.replace(/\\/g,"/")).split("/"),n=[];for(let e=0;e<t.length;++e){const r=t[e];"."!==r&&(".."===r?n.pop():n.push(r))}return n.join("/")}class Q{uniqueId;leftLoadCount;isRequesting;errorTextureDatas;constructor(e){this.uniqueId=e,this.leftLoadCount=0,this.isRequesting=!0,this.errorTextureDatas=[]}}class X{observable;hasLoadError;constructor(){this.observable=new q.cP,this.hasLoadError=!1}}class Y{cacheKey;_scene;_assetContainer;_textureName;_options;_onLoad;_onError;_forcedExtension;_texture;constructor(e,t,n,r,i,s,o,a,l,d){this.cacheKey=e,this._scene=t,this._assetContainer=n,this._textureName=i,this._options=o,this._onLoad=a,this._onError=l,this._forcedExtension=d,this._texture=null,s||t._loadFile(r,(e=>{this._createTexture(t,n,i,e,o,a,((e,t)=>{l?.(e,t)}),d)}),void 0,!0,!0,((e,t)=>{l?.(e?e.status+" "+e.statusText:"",t)}))}loadFromArrayBuffer(e){this._createTexture(this._scene,this._assetContainer,this._textureName,e,this._options,this._onLoad,((e,t)=>{this._onError?.(e,t)}),this._forcedExtension)}_onDisposeCallback=null;registerOnDisposeCallback(e){this._onDisposeCallback=e,this._texture.onDisposeObservable.addOnce(e)}unregisterOnDisposeCallback(){const e=this._onDisposeCallback;return null===e?null:(this._onDisposeCallback=null,this._texture.onDisposeObservable.removeCallback(e),e)}_createTexture(e,t,n,r,i,s,o,a){e._blockEntityCollection=!!t;const l={noMipmap:i.noMipmap,invertY:i.invertY,samplingMode:i.samplingMode,onLoad:()=>{null===this._texture?null!==s&&K._.SetImmediate(s):s?.()},onError:o,buffer:r,deleteBuffer:i.deleteBuffer,format:i.format,mimeType:i.mimeType,forcedExtension:a},d=this._texture=new W.g("data:"+n,e,l);d._parentContainer=t,e._blockEntityCollection=!1,t?.textures.push(d),d.name=n}get texture(){return this._texture}}class j{onModelTextureLoadedObservable=new Map;textureCache=new Map;_textureLoadInfoMap=new Map;_loadingModels=new Map;_errorTexturesReferenceCount=new Map;_incrementLeftLoadCount(e){let t=this._loadingModels.get(e);void 0===t&&(t=new Q(e),this._loadingModels.set(e,t)),t.leftLoadCount+=1;let n=this.onModelTextureLoadedObservable.get(e);return void 0===n&&(n=new q.cP,this.onModelTextureLoadedObservable.set(e,n)),t}_decrementLeftLoadCount(e){if(e.leftLoadCount-=1,!e.isRequesting&&0===e.leftLoadCount){this._removeErrorTexturesReferenceCount(e.uniqueId),this._loadingModels.delete(e.uniqueId);const t=this.onModelTextureLoadedObservable.get(e.uniqueId);t?.notifyObservers(),t?.clear(),this.onModelTextureLoadedObservable.delete(e.uniqueId)}}loadModelTexturesEnd(e){const t=this._loadingModels.get(e);if(void 0!==t&&(t.isRequesting=!1,0===t.leftLoadCount)){this._removeErrorTexturesReferenceCount(e),this._loadingModels.delete(e);const t=this.onModelTextureLoadedObservable.get(e);t?.notifyObservers(),t?.clear(),this.onModelTextureLoadedObservable.delete(e)}}_addErrorTextureReferenceCount(e,t){this._loadingModels.get(e).errorTextureDatas.push(t),this._errorTexturesReferenceCount.set(t,(this._errorTexturesReferenceCount.get(t)??0)+1)}_removeErrorTexturesReferenceCount(e){const t=this._loadingModels.get(e);for(let e=0;e<t.errorTextureDatas.length;++e){const n=t.errorTextureDatas[e],r=this._errorTexturesReferenceCount.get(n)-1;0===r?null!==n.texture?n.texture.dispose():(this._textureLoadInfoMap.delete(n.cacheKey),this.textureCache.delete(n.cacheKey),this._errorTexturesReferenceCount.delete(n)):this._errorTexturesReferenceCount.set(n,r)}}_handleTextureOnDispose(e){e.registerOnDisposeCallback((()=>{this._textureLoadInfoMap.delete(e.cacheKey),this.textureCache.delete(e.cacheKey),this._errorTexturesReferenceCount.delete(e)}))}_createTextureCacheKey(e,t){const n=e.lastIndexOf(".");let r="";return-1!==n&&(r=e.substring(n),e=e.substring(0,n)),e+ +(t.noMipmap??!1)+ +(t.invertY??!0)+(t.samplingMode??W.g.TRILINEAR_SAMPLINGMODE)+(t.format??o.Y.TEXTUREFORMAT_RGBA)+r}async _loadTextureAsyncInternal(e,t,n,r,i,s,o){const a=this._incrementLeftLoadCount(e),l=this._createTextureCacheKey(t,o);let d=this._textureLoadInfoMap.get(l);void 0===d&&(d=new X,this._textureLoadInfoMap.set(l,d));let h=this.textureCache.get(l);if(void 0===h&&!d.hasLoadError){const a=null!==r?H.Data[r]:t;h=new Y(l,i,s,a,t,null!==n,o,(()=>{this._handleTextureOnDispose(h),d.hasLoadError=!1,d.observable.notifyObservers(!1),d.observable.clear()}),((t,n)=>{null!==h.texture&&this._handleTextureOnDispose(h),this._addErrorTextureReferenceCount(e,h),d.hasLoadError=!0,d.observable.notifyObservers(!0),d.observable.clear()}),o.forcedExtension),this.textureCache.set(l,h);const c=n instanceof Blob?await n.arrayBuffer():n;null!==c&&h.loadFromArrayBuffer(c)}return null!==h.texture&&h.texture.isReady()?(this._decrementLeftLoadCount(a),d.hasLoadError?null:h.texture):new Promise((e=>{d.observable.addOnce((t=>{this._decrementLeftLoadCount(a),e(t?null:h.texture)}))}))}async loadTextureAsync(e,t,n,r,i,s){let o;"number"==typeof n?((n<-1||9<n)&&(n=-1),n+=1,o=!0):o=!1;const a=o?o?"file:shared_toon_texture_"+n:n:G(t+n);return await this._loadTextureAsyncInternal(e,a,null,o?n:null,r,i,s)}async loadTextureFromBufferAsync(e,t,n,r,i,s,o=!0){return o&&(t=G(t)),await this._loadTextureAsyncInternal(e,t,n,null,r,i,s)}}var $=n(2673),J=n(9259),Z=n(6877),ee=n(6552),te=n(426),ne=function(e,t,n,r){var i,s=arguments.length,o=s<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,r);else for(var a=e.length-1;a>=0;a--)(i=e[a])&&(o=(s<3?i(o):s>3?i(t,n,o):i(t,n))||o);return s>3&&o&&Object.defineProperty(t,n,o),o};class re{isMock=!0;sphereTexture=null;sphereTextureBlendMode=te.rw.Add;toonTexture=null;ignoreDiffuseWhenToonTextureIsNull=!1;applyAmbientColorToDiffuse=!0;clampAlpha=!0;textureMultiplicativeColor=new z.ov(1,1,1,1);textureAdditiveColor=new z.ov(0,0,0,0);sphereTextureMultiplicativeColor=new z.ov(1,1,1,1);sphereTextureAdditiveColor=new z.ov(0,0,0,0);toonTextureMultiplicativeColor=new z.ov(1,1,1,1);toonTextureAdditiveColor=new z.ov(0,0,0,0);useTextureColor=!1;useSphereTextureColor=!1;useToonTextureColor=!1}class ie extends $.F{_pluginMaterial;_renderOutline=!1;outlineWidth=.01;outlineColor=new z.v9(0,0,0);outlineAlpha=1;_disposed=!1;constructor(e,t,n=!1){super(e,t,n),this.specularColor=new z.v9(0,0,0),(this._pluginMaterial=new re).ignoreDiffuseWhenToonTextureIsNull=!0,this._initPluginShaderSourceAsync(this._shaderLanguage)}async _initPluginShaderSourceAsync(e){const t=e===c.w.GLSL?(await Promise.all([n.e(71),n.e(257)]).then(n.bind(n,2968))).MmdPluginMaterial:(await Promise.all([n.e(126),n.e(257)]).then(n.bind(n,9325))).MmdPluginMaterial;if(this._disposed)return;const r=this._pluginMaterial,i=this._pluginMaterial=new t(this);i.isEnabled=!0,i.sphereTexture=r.sphereTexture,i.sphereTextureBlendMode=r.sphereTextureBlendMode,i.toonTexture=r.toonTexture,i.ignoreDiffuseWhenToonTextureIsNull=r.ignoreDiffuseWhenToonTextureIsNull,i.applyAmbientColorToDiffuse=r.applyAmbientColorToDiffuse,i.clampAlpha=r.clampAlpha,i.textureMultiplicativeColor=r.textureMultiplicativeColor,i.textureAdditiveColor=r.textureAdditiveColor,i.sphereTextureMultiplicativeColor=r.sphereTextureMultiplicativeColor,i.sphereTextureAdditiveColor=r.sphereTextureAdditiveColor,i.toonTextureMultiplicativeColor=r.toonTextureMultiplicativeColor,i.toonTextureAdditiveColor=r.toonTextureAdditiveColor,i.useTextureColor=r.useTextureColor,i.useSphereTextureColor=r.useSphereTextureColor,i.useToonTextureColor=r.useToonTextureColor}dispose(e,t){super.dispose(e,t),this._disposed=!0}isReadyForSubMesh(e,t,n){return!this._pluginMaterial.isMock&&super.isReadyForSubMesh(e,t,n)}get sphereTexture(){return this._pluginMaterial.sphereTexture}set sphereTexture(e){this._pluginMaterial.sphereTexture=e}get sphereTextureBlendMode(){return this._pluginMaterial.sphereTextureBlendMode}set sphereTextureBlendMode(e){this._pluginMaterial.sphereTextureBlendMode=e}get toonTexture(){return this._pluginMaterial.toonTexture}set toonTexture(e){this._pluginMaterial.toonTexture=e}get ignoreDiffuseWhenToonTextureIsNull(){return this._pluginMaterial.ignoreDiffuseWhenToonTextureIsNull}set ignoreDiffuseWhenToonTextureIsNull(e){this._pluginMaterial.ignoreDiffuseWhenToonTextureIsNull=e}get applyAmbientColorToDiffuse(){return this._pluginMaterial.applyAmbientColorToDiffuse}set applyAmbientColorToDiffuse(e){this._pluginMaterial.applyAmbientColorToDiffuse=e}get clampAlpha(){return this._pluginMaterial.clampAlpha}set clampAlpha(e){this._pluginMaterial.clampAlpha=e}get textureMultiplicativeColor(){return this._pluginMaterial.useTextureColor=!0,this._pluginMaterial.textureMultiplicativeColor}set textureMultiplicativeColor(e){this._pluginMaterial.useTextureColor=!0,this._pluginMaterial.textureMultiplicativeColor=e}get textureAdditiveColor(){return this._pluginMaterial.useTextureColor=!0,this._pluginMaterial.textureAdditiveColor}set textureAdditiveColor(e){this._pluginMaterial.useTextureColor=!0,this._pluginMaterial.textureAdditiveColor=e}get sphereTextureMultiplicativeColor(){return this._pluginMaterial.useSphereTextureColor=!0,this._pluginMaterial.sphereTextureMultiplicativeColor}set sphereTextureMultiplicativeColor(e){this._pluginMaterial.useSphereTextureColor=!0,this._pluginMaterial.sphereTextureMultiplicativeColor=e}get sphereTextureAdditiveColor(){return this._pluginMaterial.useSphereTextureColor=!0,this._pluginMaterial.sphereTextureAdditiveColor}set sphereTextureAdditiveColor(e){this._pluginMaterial.useSphereTextureColor=!0,this._pluginMaterial.sphereTextureAdditiveColor=e}get toonTextureMultiplicativeColor(){return this._pluginMaterial.useToonTextureColor=!0,this._pluginMaterial.toonTextureMultiplicativeColor}set toonTextureMultiplicativeColor(e){this._pluginMaterial.useToonTextureColor=!0,this._pluginMaterial.toonTextureMultiplicativeColor=e}get toonTextureAdditiveColor(){return this._pluginMaterial.useToonTextureColor=!0,this._pluginMaterial.toonTextureAdditiveColor}set toonTextureAdditiveColor(e){this._pluginMaterial.useToonTextureColor=!0,this._pluginMaterial.toonTextureAdditiveColor=e}get renderOutline(){return this._renderOutline}set renderOutline(e){e&&this.getScene().getMmdOutlineRenderer?.(),this._renderOutline=e}needAlphaBlending(){return!this._disableAlphaBlending&&(super.needAlphaBlending()||null!==this._pluginMaterial.sphereTexture&&this._pluginMaterial.sphereTextureBlendMode===te.rw.Multiply)}clone(e,t=!0,n=""){const r=Z.p.Clone((()=>new ie(e,this.getScene())),this,{cloneTexturesOnlyOnce:t});return r.name=e,r.id=e,this.stencil.copyTo(r.stencil),this._clonePlugins(r,n),r}static Parse(e,t,n){const r=Z.p.Parse((()=>new ie(e.name,t)),e,t,n);return e.stencil&&r.stencil.parse(e.stencil,t,n),N.i._ParsePlugins(e,r,t,n),r}}ne([(0,J.lK)("renderOutline")],ie.prototype,"_renderOutline",void 0),ne([(0,J.lK)()],ie.prototype,"outlineWidth",void 0),ne([(0,J.jT)()],ie.prototype,"outlineColor",void 0),ne([(0,J.lK)()],ie.prototype,"outlineAlpha",void 0),(0,ee.Y5)("BABYLON.MmdStandardMaterial",ie);class se{files;_fileRootId;_fileMap=new Map;constructor(e,t,n){if(t=G(t),this.files=e,this._fileRootId=n,0!==e.length)if(e[0]instanceof File)for(const r of e){const e=G(r.webkitRelativePath);if(!e.startsWith(t))continue;const i=n+G(e.slice(t.length));this._fileMap.set(G(i).toUpperCase(),r)}else for(const t of e){const e=n+G(t.relativePath);this._fileMap.set(G(e).toUpperCase(),t)}}createFullPath(e){return this._fileRootId+G(e)}resolve(e){const t=G(e);return this._fileMap.get(t.toUpperCase())}}var oe,ae,le=n(917),de=n(6882);!function(e){e[e.Opaque=N.i.MATERIAL_OPAQUE]="Opaque",e[e.AlphaTest=N.i.MATERIAL_ALPHATEST]="AlphaTest",e[e.AlphaBlend=N.i.MATERIAL_ALPHABLEND]="AlphaBlend"}(oe||(oe={}));class he{_scene;_renderTargetTexture;_resultPixelsBuffer;constructor(e,t=512){this._scene=e;const n=e.getEngine(),r=this._renderTargetTexture=new de.$("texture_alpha_checker",t,e,{generateDepthBuffer:!1,generateStencilBuffer:!1,generateMipMaps:!1,type:o.Y.TEXTURETYPE_UNSIGNED_BYTE,format:n.isWebGPU||n.version>1?o.Y.TEXTUREFORMAT_RED:o.Y.TEXTUREFORMAT_RGBA,doNotChangeAspectRatio:!0});r.noPrePassRenderer=!0,r.anisotropicFilteringLevel=1,r.renderParticles=!1,r.optimizeUVAllocation=!0,r.ignoreCameraViewport=!0,r.clearColor=new z.ov(0,0,0,1),this._resultPixelsBuffer=new Uint8Array(t*t*4)}async _renderTexture(e,t,n){const r=he._GetShader(this._scene);r.setTexture("textureSampler",e);let i=null;null!==n&&(i=t.subMeshes,t.subMeshes=[t.subMeshes[n]]);const s=this._renderTargetTexture;for(s.renderList=[t],s.setMaterialForRendering(t,r);!s.isReadyForRendering()||!r.isReady();)if(await new Promise((e=>{setTimeout(e,0)})),null===s._texture)return new Uint8Array(0);const o=t._internalAbstractMeshDataInfo._currentLODIsUpToDate,a=t._internalAbstractMeshDataInfo._currentLOD;t._internalAbstractMeshDataInfo._currentLODIsUpToDate=!0,t._internalAbstractMeshDataInfo._currentLOD=t;const l=t._nodeDataStorage._isEnabled,d=t._nodeDataStorage._isParentEnabled;t._nodeDataStorage._isEnabled=!0,t._nodeDataStorage._isParentEnabled=!0,s.render(!1,!1),t._nodeDataStorage._isParentEnabled=d,t._nodeDataStorage._isEnabled=l,t._internalAbstractMeshDataInfo._currentLOD=a,t._internalAbstractMeshDataInfo._currentLODIsUpToDate=o;const h=r.getEffect();t.geometry._releaseVertexArrayObject(h);const c=t.subMeshes;for(let e=0,t=c.length;e<t;++e)c[e]._removeDrawWrapper(s.renderPassId,!0);null!==i&&(t.subMeshes=i);const u=this._resultPixelsBuffer;return await s.readPixels(void 0,void 0,u),u}_blockRendering=!1;_taskQueue=[];async hasTranslucentFragmentsOnGeometry(e,t,n,r,i){if(!e.isReady())throw new Error("Texture is not ready");this._blockRendering&&await new Promise((e=>{this._taskQueue.push(e)})),this._blockRendering=!0;const s=await this._renderTexture(e,t,n);let o=0,a=0,l=0;for(let e=0;e<s.length;e+=4){const t=s[e];o=Math.max(o,t),0<t&&t<255&&(a+=t,l+=1)}0!==l&&(a/=l),this._blockRendering=!1;const d=this._taskQueue.shift();return void 0!==d&&d(),o<r?oe.Opaque:a+i<o?oe.AlphaTest:oe.AlphaBlend}async hasFragmentsOnlyOpaqueOnGeometry(e,t,n){if(!e.isReady())throw new Error("Texture is not ready");this._blockRendering&&await new Promise((e=>{this._taskQueue.push(e)})),this._blockRendering=!0;const r=await this._renderTexture(e,t,n);for(let e=0;e<r.length;e+=4)if(0!==r[e]){this._blockRendering=!1;const e=this._taskQueue.shift();return void 0!==e&&e(),!1}this._blockRendering=!1;const i=this._taskQueue.shift();return void 0!==i&&i(),!0}dispose(){this._renderTargetTexture.dispose()}static _GetShader(e){if(!e._textureAlphaCheckerShader){const t=e.getEngine().isWebGPU?c.w.WGSL:c.w.GLSL,r=new le.B("textureAlphaChecker",e,{vertex:"textureAlphaChecker",fragment:"textureAlphaChecker"},{needAlphaBlending:!1,needAlphaTesting:!1,attributes:["uv"],uniforms:[],samplers:["textureSampler"],shaderLanguage:t,extraInitializationsAsync:async()=>{t===c.w.WGSL?await Promise.all([n.e(126).then(n.bind(n,1306)),n.e(126).then(n.bind(n,6876))]):await Promise.all([n.e(71).then(n.bind(n,9457)),n.e(71).then(n.bind(n,71))])}});r.backFaceCulling=!1,r.alphaMode=o.Y.ALPHA_DISABLE,e.onDisposeObservable.add((()=>{e._textureAlphaCheckerShader?.dispose(),e._textureAlphaCheckerShader=null})),e._textureAlphaCheckerShader=r}return e._textureAlphaCheckerShader}static DisposeShader(e){e._textureAlphaCheckerShader?.dispose(),e._textureAlphaCheckerShader=null}}!function(e){e[e.DepthWriteAlphaBlendingWithEvaluation=0]="DepthWriteAlphaBlendingWithEvaluation",e[e.DepthWriteAlphaBlending=1]="DepthWriteAlphaBlending",e[e.AlphaEvaluation=2]="AlphaEvaluation"}(ae||(ae={}));class ce{renderMethod=ae.DepthWriteAlphaBlendingWithEvaluation;forceDisableAlphaEvaluation=!1;alphaThreshold=195;alphaBlendThreshold=100;alphaEvaluationResolution=512;deleteTextureBufferAfterLoad=!0;_textureLoader=new j;nextStartingAlphaIndex=65536;alphaIndexIncrementsPerModel=1024;_setMeshesAlphaIndex(e){let t=this.nextStartingAlphaIndex;for(let n=0;n<e.length;++n)e[n].alphaIndex=t,t+=1;this.nextStartingAlphaIndex+=this.alphaIndexIncrementsPerModel}buildMaterials(e,t,n,r,i,s,o,a,l,d,h,c,u,p,g){this.renderMethod!==ae.DepthWriteAlphaBlendingWithEvaluation&&this.renderMethod!==ae.DepthWriteAlphaBlending||this._setMeshesAlphaIndex(l);const f=d.blockMaterialDirtyMechanism;d._forceBlockMaterialDirtyMechanism(!0);let m=null;const x=()=>null!==m?m:this.forceDisableAlphaEvaluation?null:m=new he(d,this.alphaEvaluationResolution),y=new se(o,i,s),A=[],T={lengthComputable:!0,loaded:0,total:3*t.length},M=()=>{T.loaded+=1,p?.(T)},_=[];for(let s=0;s<t.length;++s){const o=t[s];d._blockEntityCollection=!!h;const l=new ie(o.name,d);l._parentContainer=h,d._blockEntityCollection=!1,h?.materials.push(l);{const t=[],c=this.loadGeneralScalarProperties(l,o,a[s]);void 0!==c&&t.push(c);const p=this.loadDiffuseTexture(e,l,o,r,n[o.textureIndex]??null,d,h,i,y,u,M),g=()=>this.setAlphaBlendMode(l,o,a[s],u,x);if(void 0!==p){const e=p.then(g);t.push(e)}else{const e=g();void 0!==e&&t.push(e)}const f=this.loadSphereTexture(e,l,o,r,n[o.sphereTextureIndex]??null,d,h,i,y,u,M);void 0!==f&&t.push(f);const m=this.loadToonTexture(e,l,o,r,n[o.toonTextureIndex]??null,d,h,i,y,u,M);void 0!==m&&t.push(m);const T=this.loadOutlineRenderingProperties(l,o,u);void 0!==T&&t.push(T),A.push(...t),Promise.all(t).then((()=>{this.afterBuildSingleMaterial(l,s,o,r,n,d,i)}))}_.push(l)}this._textureLoader.loadModelTexturesEnd(e);const b=this._textureLoader.onModelTextureLoadedObservable.get(e);return void 0!==b?b.addOnce((()=>{Promise.all(A).then((()=>{m?.dispose(),d._forceBlockMaterialDirtyMechanism(f),null!==c&&this._buildTextureNameMap(t,_,r,n,c),g?.()}))})):Promise.all(A).then((()=>{m?.dispose(),d._forceBlockMaterialDirtyMechanism(f),null!==c&&this._buildTextureNameMap(t,_,r,n,c),g?.()})),_}_buildTextureNameMap(e,t,n,r,i){for(let s=0;s<e.length;++s){const o=e[s],a=t[s],l=n[r[o.textureIndex]?.imagePathIndex];if(void 0!==l){const e=a.diffuseTexture;null!==e&&i.set(e,l)}const d=n[r[o.sphereTextureIndex]?.imagePathIndex];if(void 0!==d){const e=a.sphereTexture;null!==e&&i.set(e,d)}const h=n[r[o.toonTextureIndex]?.imagePathIndex];if(void 0!==h){const e=a.toonTexture;null!==e&&i.set(e,h)}}}loadGeneralScalarProperties=(e,t,n)=>{const r=t.diffuse;e.diffuseColor=new z.v9(r[0],r[1],r[2]);const i=t.specular;e.specularColor=new z.v9(i[0],i[1],i[2]);const s=t.ambient;e.ambientColor=new z.v9(s[0],s[1],s[2]);const o=t.diffuse[3];if(e.alpha=o,0===o)for(let e=0;e<n.length;++e){const t=n[e];void 0!==t.isVisible&&(t.isVisible=!1)}e.specularPower=t.shininess};loadDiffuseTexture=async(e,t,n,r,i,s,a,l,d,h,c)=>{t.backFaceCulling=!(n.flag&b.Material.Flag.IsDoubleSided);const u=r[i?.imagePathIndex??-1];if(void 0!==u){const n=d.createFullPath(u);let r;const p=d.resolve(n);r=void 0!==p?await this._textureLoader.loadTextureFromBufferAsync(e,n,p instanceof File?p:p.data,s,a,{...i,deleteBuffer:this.deleteTextureBufferAfterLoad,format:o.Y.TEXTUREFORMAT_RGBA,mimeType:p instanceof File?p.type:p.mimeType}):await this._textureLoader.loadTextureAsync(e,l,u,s,a,{...i,deleteBuffer:this.deleteTextureBufferAfterLoad,format:o.Y.TEXTUREFORMAT_RGBA});const g=r;null!==g?t.diffuseTexture=g:h.error(`Failed to load diffuse texture: ${n}`),c?.()}else c?.()};async _evaluateDiffuseTextureTransparencyMode(e,t,n,r,i){let s=Number.MIN_SAFE_INTEGER;if(this.renderMethod===ae.DepthWriteAlphaBlendingWithEvaluation){let r=t>>4&3;if(0==(3^r)&&(r=-1),-1===r){s=N.i.MATERIAL_OPAQUE;const t=i();if(null!==t)for(let r=0;r<n.length;++r){const i=n[r];if(!await t.hasFragmentsOnlyOpaqueOnGeometry(e,i?.mesh??i,void 0!==i?.subMeshIndex?i.subMeshIndex:null)){s=N.i.MATERIAL_ALPHABLEND;break}}}else s=0===r?N.i.MATERIAL_OPAQUE:N.i.MATERIAL_ALPHABLEND}else if(this.renderMethod===ae.AlphaEvaluation){let r=15&t;if(0==(15^r)&&(r=-1),-1!==r)s=r;else{const t=i();if(null!==t)for(let r=0;r<n.length;++r){const i=n[r],o=await t.hasTranslucentFragmentsOnGeometry(e,i?.mesh??i,void 0!==i?.subMeshIndex?i.subMeshIndex:null,this.alphaThreshold,this.alphaBlendThreshold);s<o&&(s=o)}}}else r.warn(`Unknown shading method for evaluating transparency mode: ${this.renderMethod}`);return s!==Number.MIN_SAFE_INTEGER?s:null}setAlphaBlendMode=async(e,t,n,r,i)=>{if(this.renderMethod===ae.DepthWriteAlphaBlending)return e.diffuseTexture&&(e.diffuseTexture.hasAlpha=!0,e.useAlphaFromDiffuseTexture=!0),e.transparencyMode=N.i.MATERIAL_ALPHABLEND,void(e.forceDepthWrite=!0);if(this.renderMethod===ae.DepthWriteAlphaBlendingWithEvaluation&&e.alpha<1)return e.diffuseTexture&&(e.diffuseTexture.hasAlpha=!0,e.useAlphaFromDiffuseTexture=!0),e.transparencyMode=N.i.MATERIAL_ALPHABLEND,void(e.forceDepthWrite=!0);const s=e.diffuseTexture,o=t.evaluatedTransparency??-1;if(null!==s){const t=await this._evaluateDiffuseTextureTransparencyMode(s,o,n,r,i);if(null!==t){const n=t!==N.i.MATERIAL_OPAQUE;n&&(s.hasAlpha=!0),e.useAlphaFromDiffuseTexture=n,e.transparencyMode=t,this.renderMethod===ae.DepthWriteAlphaBlendingWithEvaluation&&(e.forceDepthWrite=n)}}else if(this.renderMethod===ae.DepthWriteAlphaBlendingWithEvaluation){let t=o>>4&3;0==(3^t)&&(t=0),e.transparencyMode=0===t?N.i.MATERIAL_OPAQUE:N.i.MATERIAL_ALPHABLEND}else{let t=15&o;0==(15^t)&&(t=0),e.transparencyMode=N.i.MATERIAL_OPAQUE}};loadSphereTexture=async(e,t,n,r,i,s,a,l,d,h,c)=>{if(n.sphereTextureMode!==b.Material.SphereTextureMode.Off){const u=r[i?.imagePathIndex??-1];if(void 0!==u){const r=s.getEngine().isWebGPU||n.sphereTextureMode===b.Material.SphereTextureMode.Multiply?o.Y.TEXTUREFORMAT_RGBA:o.Y.TEXTUREFORMAT_RGB,p=d.createFullPath(u);let g;const f=d.resolve(p);g=void 0!==f?await this._textureLoader.loadTextureFromBufferAsync(e,p,f instanceof File?f:f.data,s,a,{...i,deleteBuffer:this.deleteTextureBufferAfterLoad,format:r,mimeType:f instanceof File?f.type:f.mimeType}):await this._textureLoader.loadTextureAsync(e,l,u,s,a,{...i,deleteBuffer:this.deleteTextureBufferAfterLoad,format:r}),null!==g?(t.sphereTexture=g,t.sphereTextureBlendMode=n.sphereTextureMode):h.error(`Failed to load sphere texture: ${p}`),c?.()}else c?.()}else c?.()};loadToonTexture=async(e,t,n,r,i,s,a,l,d,h,c)=>{let u;if(u=n.isSharedToonTexture?n.toonTextureIndex:r[i?.imagePathIndex??-1],void 0!==u){const n=d.createFullPath(u.toString());let r;const p="string"==typeof u?d.resolve(n):void 0;r=void 0!==p?await this._textureLoader.loadTextureFromBufferAsync(e,n,p instanceof File?p:p.data,s,a,{...i,deleteBuffer:this.deleteTextureBufferAfterLoad,format:s.getEngine().isWebGPU?o.Y.TEXTUREFORMAT_RGBA:o.Y.TEXTUREFORMAT_RGB,mimeType:p instanceof File?p.type:p.mimeType}):await this._textureLoader.loadTextureAsync(e,l,u,s,a,{...i,deleteBuffer:this.deleteTextureBufferAfterLoad,format:s.getEngine().isWebGPU?o.Y.TEXTUREFORMAT_RGBA:o.Y.TEXTUREFORMAT_RGB}),null!==r?t.toonTexture=r:h.error(`Failed to load toon texture: ${n}`),c?.()}else c?.()};loadOutlineRenderingProperties=(e,t,n)=>{if(t.flag&b.Material.Flag.EnabledToonEdge){void 0===p.Z.prototype.getMmdOutlineRenderer&&n.warn('MMD Outline Renderer is not available. Please import "babylon-mmd/esm/Loader/mmdOutlineRenderer".'),e.renderOutline=!0,e.outlineWidth=t.edgeSize;const r=t.edgeColor;e.outlineColor=new z.v9(r[0],r[1],r[2]),e.outlineAlpha=r[3]}};afterBuildSingleMaterial=()=>{}}class ue{lengthComputable;total;_onProgress;_unprocessedTasks;_processingTasks;_endedTaskNames;_endedTasksTotal;constructor(e,t,n){this.lengthComputable=e;let r=0;for(let e=0;e<t.length;++e)r+=t[e].cost;this.total=r,this._onProgress=n;const i=this._unprocessedTasks=new Map;for(let e=0;e<t.length;++e){if(i.has(t[e].name))throw new Error(`Duplicated task name: ${t[e].name}`);i.set(t[e].name,t[e])}this._processingTasks=new Map,this._endedTaskNames=new Set,this._endedTasksTotal=0}_getTaskState(e){let t=this._processingTasks.get(e);if(void 0===t){const n=this._unprocessedTasks.get(e);if(void 0===n){if(this._endedTaskNames.has(e))return null;throw new Error(`Task not found: ${e}`)}t={name:n.name,cost:n.cost,progress:0},this._processingTasks.set(e,t),this._unprocessedTasks.delete(e)}return t}processTask(e,t){const n=this._getTaskState(e);null!==n&&(n.progress+=t,n.progress>=n.cost&&(this._processingTasks.delete(e),this._endedTaskNames.add(e),this._endedTasksTotal+=n.cost))}setTaskProgress(e,t){const n=this._getTaskState(e);return null!==n&&(n.progress=t,n.progress>=n.cost&&(this._processingTasks.delete(e),this._endedTaskNames.add(e),this._endedTasksTotal+=n.cost),!0)}setTaskProgressRatio(e,t,n){const r=this._getTaskState(e);return null!==r&&(r.progress=n?Math.floor(r.cost*t):r.cost*t,r.progress>=r.cost&&(this._processingTasks.delete(e),this._endedTaskNames.add(e),this._endedTasksTotal+=r.cost),!0)}endTask(e){const t=this._getTaskState(e);null!==t&&(this._processingTasks.delete(e),this._endedTaskNames.add(e),this._endedTasksTotal+=t.cost)}invokeProgressEvent(){null!==this._onProgress&&this._onProgress({lengthComputable:this.lengthComputable,loaded:this.loaded,total:this.total})}get loaded(){let e=this._endedTasksTotal;for(const[t,n]of this._processingTasks)e+=n.progress;return e}}class pe{name;extensions;materialBuilder;useSdef;buildSkeleton;buildMorph;boundingBoxMargin;preserveSerializationData;_loggingEnabled;log;warn;error;static _SharedStandardMaterialBuilder=new ce;constructor(e,t,n={},r){this.name=e,this.extensions=t,r=r??{materialBuilder:pe._SharedStandardMaterialBuilder,useSdef:!0,buildSkeleton:!0,buildMorph:!0,boundingBoxMargin:10,preserveSerializationData:!1,loggingEnabled:!1},this.materialBuilder=n.materialBuilder??r.materialBuilder,this.useSdef=n.useSdef??r.useSdef,this.buildSkeleton=n.buildSkeleton??r.buildSkeleton,this.buildMorph=n.buildMorph??r.buildMorph,this.boundingBoxMargin=n.boundingBoxMargin??r.boundingBoxMargin,this.preserveSerializationData=n.preserveSerializationData??r.preserveSerializationData,this._loggingEnabled=n.loggingEnabled??r.loggingEnabled,this._loggingEnabled?(this.log=this._logEnabled,this.warn=this._warnEnabled,this.error=this._errorEnabled):(this.log=this._logDisabled,this.warn=this._warnDisabled,this.error=this._errorDisabled)}importMeshAsync(e,t,n,r,i,s){return this._loadAsyncInternal(t,null,n,r,i)}loadAsync(e,t,n,r,i){return this._loadAsyncInternal(e,null,t,n,r).then((()=>{}))}loadAssetContainerAsync(e,t,n,r,i){const s=new P.WZ(e);return this._loadAsyncInternal(e,s,t,n,r).then((()=>s))}async _loadAsyncInternal(e,t,n,r,i){const s=await this._parseFileAsync(n.arrayBuffer),o=new ue(!0,this._getProgressTaskCosts(n,s),i??null);o.endTask("Parse"),o.invokeProgressEvent(),e._blockEntityCollection=!!t;const a=new F.e(s.header.modelName,e);a._parentContainer=t,e._blockEntityCollection=!1,a.setEnabled(!1);const l=await this._buildGeometryAsync(n,s,a,e,t,o),d=n.preserveSerializationData?new Map:null,{materials:h,multiMaterials:c,textureLoadPromise:u}=await this._buildMaterialAsync(n,s,a,l.meshes,d,e,t,r,o),p=[];let g=null;n.buildSkeleton?g=await this._buildSkeletonAsync(n,s,l.meshes,e,t,p,o):o.endTask("Build Skeleton");const f=[];let m=null;if(n.buildMorph&&(m=await this._buildMorphAsync(n,s,l,e,t,f,o)),0!==n.boundingBoxMargin&&this._applyBoundingBoxMargin(l.meshes,n.boundingBoxMargin),a.metadata={isMmdModel:!0,header:{modelName:s.header.modelName,englishModelName:s.header.englishModelName,comment:s.header.comment,englishComment:s.header.englishComment},bones:p,morphs:f,rigidBodies:s.rigidBodies,joints:s.joints,meshes:l.meshes,materials:h,skeleton:g},n.preserveSerializationData){const e=[],t=s.materials;for(let n=0;n<t.length;++n){const r=t[n];e.push({englishName:r.englishName,comment:r.comment})}a.metadata={...a.metadata,containsSerializationData:!0,textureNameMap:d,materialsMetadata:e,displayFrames:s.displayFrames}}return o.invokeProgressEvent(),await u,o.endTask("Texture Load"),o.invokeProgressEvent(),a.setEnabled(!0),null!==t&&(t.rootNodes.push(a),t.meshes.push(a,...l.meshes),t.geometries.push(...l.geometries),t.materials.push(...h),t.multiMaterials.push(...c),null!==g&&t.skeletons.push(g),null!==m&&t.morphTargetManagers.push(...m)),{meshes:[a,...l.meshes],particleSystems:[],skeletons:null!==g?[g]:[],animationGroups:[],transformNodes:[],geometries:l.geometries,lights:[],spriteManagers:[]}}_getProgressTaskCosts(e,t){return[{name:"Parse",cost:Math.floor(e.arrayBuffer.byteLength/100)},{name:"Build Material",cost:100*t.materials.length},{name:"Build Skeleton",cost:e.buildSkeleton?100*t.bones.length:0},{name:"Texture Load",cost:3e4*t.textures.length}]}async _buildSkeletonAsync(e,t,n,r,i,s,o){const a=e.preserveSerializationData;r._blockEntityCollection=!!i;const l=new V.E(t.header.modelName,t.header.modelName+"_skeleton",r);l._parentContainer=i,r._blockEntityCollection=!1;{const e=t.bones,n=[],r=[];for(let t=0;t<e.length;++t){const i=e[t];let o=!1;if(0<=i.parentBoneIndex&&i.parentBoneIndex<e.length){let n=i.parentBoneIndex;for(let r=0;r<e.length&&-1!==n;++r){if(n===t){o=!0,this.warn(`Bone loop detected. Ignore Parenting. Bone index: ${t}`);break}n=e[n].parentBoneIndex}t<=i.parentBoneIndex&&this.warn(`Parent bone index is greater equal than child bone index. Bone index: ${t} Parent bone index: ${i.parentBoneIndex}`)}else-1!==i.parentBoneIndex&&this.error(`Parent bone index is out of range. Bone index: ${t} Parent bone index: ${i.parentBoneIndex}`);const d=i.position,h=new u.Pq(d[0],d[1],d[2]);if(0<=i.parentBoneIndex&&i.parentBoneIndex<e.length&&!o){const t=e[i.parentBoneIndex];h.x-=t.position[0],h.y-=t.position[1],h.z-=t.position[2]}const c=u.uq.Identity().setTranslation(h),p=new k.$(i.name,l,void 0,c,void 0,void 0,t);n.push(p),r.push(o);const g={name:i.name,englishName:i.englishName,parentBoneIndex:i.parentBoneIndex,transformOrder:i.transformOrder,flag:i.flag,appendTransform:i.appendTransform,axisLimit:i.axisLimit,ik:i.ik,...a?{tailPosition:i.tailPosition,localVector:i.localVector,externalParentTransform:i.externalParentTransform}:void 0};s.push(g)}for(let t=0;t<n.length;++t){const i=e[t],s=n[t];0<=i.parentBoneIndex&&i.parentBoneIndex<n.length&&!r[t]&&s.setParent(n[i.parentBoneIndex],!1)}for(let e=0;e<n.length;++e){const t=n[e];null===t.getParent()&&t._updateAbsoluteBindMatrices()}}o.endTask("Build Skeleton"),o.invokeProgressEvent();for(let e=0;e<n.length;++e)n[e].skeleton=l;return l}_applyBoundingBoxMargin(e,t){for(let n=0;n<e.length;++n){const r=e[n];if(void 0===r.subMeshes)continue;const i=r.subMeshes;for(let e=0;e<i.length;++e){const n=i[e],r=n.getBoundingInfo();n.setBoundingInfo(new L.j((new u.Pq).setAll(-t).addInPlace(r.minimum),(new u.Pq).setAll(t).addInPlace(r.maximum)))}const s=r.getBoundingInfo();r.setBoundingInfo(new L.j((new u.Pq).setAll(-t).addInPlace(s.minimum),(new u.Pq).setAll(t).addInPlace(s.maximum))),r._updateBoundingInfo()}}get loggingEnabled(){return this._loggingEnabled}set loggingEnabled(e){this._loggingEnabled=e,e?(this.log=this._logEnabled,this.warn=this._warnEnabled,this.error=this._errorEnabled):(this.log=this._logDisabled,this.warn=this._warnDisabled,this.error=this._errorDisabled)}_logEnabled(e){O.V.Log(e)}_logDisabled(){}_warnEnabled(e){O.V.Warn(e)}_warnDisabled(){}_errorEnabled(e){O.V.Error(e)}_errorDisabled(){}}class ge{static _IdMap=new WeakMap;static _NextId=0;constructor(){}static GetId(e){let t=this._IdMap.get(e);return void 0===t&&(t=this._NextId,this._NextId+=1,this._IdMap.set(e,t)),t}}class fe extends F.e{applySkeleton(e){if(!this.geometry)return this;if(this.geometry._softwareSkinningFrameId===this.getScene().getFrameId())return this;if(this.geometry._softwareSkinningFrameId=this.getScene().getFrameId(),!this.isVerticesDataPresent(s.R.PositionKind))return this;if(!this.isVerticesDataPresent(s.R.MatricesIndicesKind))return this;if(!this.isVerticesDataPresent(s.R.MatricesWeightsKind))return this;const t=this.isVerticesDataPresent(s.R.NormalKind),n=this._internalMeshDataInfo;if(!n._sourcePositions){const e=this.subMeshes.slice();this.setPositionsForCPUSkinning(),this.subMeshes=e}t&&!n._sourceNormals&&this.setNormalsForCPUSkinning();let r=this.getVerticesData(s.R.PositionKind);if(!r)return this;r instanceof Float32Array||(r=new Float32Array(r));let i=this.getVerticesData(s.R.NormalKind);if(t){if(!i)return this;i instanceof Float32Array||(i=new Float32Array(i))}const o=this.isVerticesDataPresent(f.V.MatricesSdefCKind);let a=null,l=null,d=null;o&&(a=this.getVerticesData(f.V.MatricesSdefCKind),l=this.getVerticesData(f.V.MatricesSdefRW0Kind),d=this.getVerticesData(f.V.MatricesSdefRW1Kind));const h=this.getVerticesData(s.R.MatricesIndicesKind),c=this.getVerticesData(s.R.MatricesWeightsKind);if(!c||!h)return this;const p=this.numBoneInfluencers>4,g=p?this.getVerticesData(s.R.MatricesIndicesExtraKind):null,m=p?this.getVerticesData(s.R.MatricesWeightsExtraKind):null,x=e.getTransformMatrices(this),y=u.Pq.Zero(),A=new u.uq,T=new u.uq,M=new u.uq,_=new u.uq,b=new u.PT,I=new u.PT,v=new u.Pq,w=n._sourcePositions,E=n._sourceNormals;let S,C=0;for(let e=0;e<r.length;e+=3,C+=4){let n=0;if(o&&(n=l[e]),0===n){let n;for(S=0;S<4;S++)n=c[C+S],n>0&&(u.uq.FromFloat32ArrayToRefScaled(x,Math.floor(16*h[C+S]),n,T),A.addToSelf(T));if(p)for(S=0;S<4;S++)n=m[C+S],n>0&&(u.uq.FromFloat32ArrayToRefScaled(x,Math.floor(16*g[C+S]),n,T),A.addToSelf(T));u.Pq.TransformCoordinatesFromFloatsToRef(w[e],w[e+1],w[e+2],A,y),y.toArray(r,e),t&&(u.Pq.TransformNormalFromFloatsToRef(E[e],E[e+1],E[e+2],A,y),y.toArray(i,e)),A.reset()}else{const n=c[C+0],s=c[C+1];u.uq.FromArrayToRef(x,Math.floor(16*h[C+0]),M),u.uq.FromArrayToRef(x,Math.floor(16*h[C+1]),_),u.PT.FromRotationMatrixToRef(M,b),u.PT.FromRotationMatrixToRef(_,I),u.uq.FromQuaternionToRef(u.PT.SlerpToRef(b,I,s,b),T),u.Pq.TransformCoordinatesFromFloatsToRef(w[e]-a[e],w[e+1]-a[e+1],w[e+2]-a[e+2],T,v),u.Pq.TransformCoordinatesFromFloatsToRef(l[e],l[e+1],l[e+2],M,y).scaleAndAddToRef(n,v),u.Pq.TransformCoordinatesFromFloatsToRef(d[e],d[e+1],d[e+2],_,y).scaleAndAddToRef(s,v),v.toArray(r,e),t&&(u.Pq.TransformNormalFromFloatsToRef(E[e],E[e+1],E[e+2],T,v),v.toArray(i,e))}}return this.updateVerticesData(s.R.PositionKind,r),t&&this.updateVerticesData(s.R.NormalKind,i),this}getClassName(){return"SdefMesh"}clone(e="",t=null,n,r=!0){return new fe(e,this.getScene(),t,this,n,r)}}(0,ee.Y5)("BABYLON.SdefMesh",fe);class me extends pe{referenceFiles;constructor(e,t,n={},r){super(e,t,n,r),this.referenceFiles=n.referenceFiles??r?.referenceFiles??[]}loadFile(e,t,n,r,i,s,o){const a=this.materialBuilder,l=this.useSdef,d=this.buildSkeleton,h=this.buildMorph,c=this.boundingBoxMargin,u=this.referenceFiles,p=this.preserveSerializationData;return e._loadFile(t,((e,n)=>{const i={arrayBuffer:e,pmFileId:t instanceof File?ge.GetId(t).toString():t,materialBuilder:a,useSdef:l,buildSkeleton:d,buildMorph:h,boundingBoxMargin:c,referenceFiles:u,preserveSerializationData:p};r(i,n)}),i,!0,s,o)}_getProgressTaskCosts(e,t){const n=super._getProgressTaskCosts(e,t);if(n.push({name:"Build Geometry",cost:t.indices.length}),e.buildMorph){let e=0;const r=t.morphs;for(let t=0;t<r.length;++t){const n=r[t];n.type!==b.Morph.Type.VertexMorph&&n.type!==b.Morph.Type.UvMorph&&n.type!==b.Morph.Type.AdditionalUvMorph1&&n.type!==b.Morph.Type.AdditionalUvMorph2&&n.type!==b.Morph.Type.AdditionalUvMorph3&&n.type!==b.Morph.Type.AdditionalUvMorph4||(e+=n.indices.length)}n.push({name:"Build Morph",cost:e})}return n}async _buildGeometryAsync(e,t,n,r,i,s){const o=[],a=[];let l;const d=[];{l=t.indices instanceof Uint8Array||t.indices instanceof Uint16Array?new Uint16Array(t.indices.length):new Uint32Array(t.indices.length);{const e=t.indices;for(let t=0;t<l.length;t+=3)l[t+0]=e[t+0],l[t+1]=e[t+2],l[t+2]=e[t+1]}const h=t.materials;let c=0;for(let u=0;u<h.length;++u){const p=h[u],g=new Uint8Array(t.vertices.length);let m=0;{const e=p.indexCount;for(let t=0;t<e;++t){const e=l[c+t];0===g[e]&&(g[e]=1,m+=1)}g.fill(0)}const x=new B.P,y=[];if(e.preserveSerializationData)for(let e=0;e<t.header.additionalVec4Count;++e)y.push(new Float32Array(4*m));let A=null,T=null,M=null,_=null,I=null;e.buildSkeleton&&e.useSdef&&(A=new Float32Array(3*m),T=new Float32Array(3*m),M=new Float32Array(3*m),_=new Float32Array(3*m),I=new Float32Array(3*m));let v=!1,w=null;e.preserveSerializationData&&(w=new Float32Array(m));const E=new t.indices.constructor(t.vertices.length);{const n=new Float32Array(3*m),r=new Float32Array(3*m),i=new Float32Array(2*m),o=new l.constructor(p.indexCount);let a=null,d=null;e.buildSkeleton&&(a=new Float32Array(4*m),d=new Float32Array(4*m));let h=performance.now(),u=0,f=0;const S=p.indexCount;for(let p=0;p<S;++p){const m=l[c+p];if(0===g[m]){g[m]=1;const s=t.vertices[m];n[3*u+0]=s.position[0],n[3*u+1]=s.position[1],n[3*u+2]=s.position[2],r[3*u+0]=s.normal[0],r[3*u+1]=s.normal[1],r[3*u+2]=s.normal[2],i[2*u+0]=s.uv[0],i[2*u+1]=1-s.uv[1];const l=s.additionalVec4;for(let e=0;e<y.length;++e)y[e][4*u+0]=l[e][0],y[e][4*u+1]=l[e][1],y[e][4*u+2]=l[e][2],y[e][4*u+3]=l[e][3];if(e.buildSkeleton)switch(s.weightType){case b.Vertex.BoneWeightType.Bdef1:{const e=s.boneWeight;a[4*u+0]=e.boneIndices,a[4*u+1]=0,a[4*u+2]=0,a[4*u+3]=0,d[4*u+0]=1,d[4*u+1]=0,d[4*u+2]=0,d[4*u+3]=0}break;case b.Vertex.BoneWeightType.Bdef2:{const e=s.boneWeight;a[4*u+0]=e.boneIndices[0],a[4*u+1]=e.boneIndices[1],a[4*u+2]=0,a[4*u+3]=0,d[4*u+0]=e.boneWeights,d[4*u+1]=1-e.boneWeights,d[4*u+2]=0,d[4*u+3]=0}break;case b.Vertex.BoneWeightType.Bdef4:case b.Vertex.BoneWeightType.Qdef:{const e=s.boneWeight;a[4*u+0]=e.boneIndices[0],a[4*u+1]=e.boneIndices[1],a[4*u+2]=e.boneIndices[2],a[4*u+3]=e.boneIndices[3],d[4*u+0]=e.boneWeights[0],d[4*u+1]=e.boneWeights[1],d[4*u+2]=e.boneWeights[2],d[4*u+3]=e.boneWeights[3]}break;case b.Vertex.BoneWeightType.Sdef:{const t=s.boneWeight;a[4*u+0]=t.boneIndices[0],a[4*u+1]=t.boneIndices[1],a[4*u+2]=0,a[4*u+3]=0;const n=t.boneWeights,r=n.boneWeight0,i=1-r;if(d[4*u+0]=r,d[4*u+1]=i,d[4*u+2]=0,d[4*u+3]=0,e.useSdef){const e=n.c[0],t=n.c[1],s=n.c[2];let o=n.r0[0],a=n.r0[1],l=n.r0[2],d=n.r1[0],h=n.r1[1],c=n.r1[2];T[3*u+0]=o,T[3*u+1]=a,T[3*u+2]=l,M[3*u+0]=d,M[3*u+1]=h,M[3*u+2]=c;const p=o*r+d*i,g=a*r+h*i,f=l*r+c*i;o=e+o-p,a=t+a-g,l=s+l-f,d=e+d-p,h=t+h-g,c=s+c-f;const m=.5*(e+o),x=.5*(t+a),y=.5*(s+l),b=.5*(e+d),w=.5*(t+h),E=.5*(s+c);A[3*u+0]=e,A[3*u+1]=t,A[3*u+2]=s,_[3*u+0]=m,_[3*u+1]=x,_[3*u+2]=y,I[3*u+0]=b,I[3*u+1]=w,I[3*u+2]=E,v=!0}}}e.preserveSerializationData&&(w[u]=s.edgeScale),o[f]=u,E[m]=u,f+=1,u+=1}else o[f]=E[m],f+=1;(c+p)%1e4==0&&100<performance.now()-h&&(s.setTaskProgress("Build Geometry",c+p),s.invokeProgressEvent(),await R.S0.DelayAsync(0),h=performance.now())}x.positions=n,x.normals=r,x.uvs=i,x.indices=o,x.matricesIndices=a,x.matricesWeights=d}r._blockEntityCollection=!!i;const S=new(e.useSdef&&v?fe:F.e)(p.name,r);S._parentContainer=i,r._blockEntityCollection=!1,S.setParent(n),o.push(S),r._blockEntityCollection=!!i;const U=new C.V(t.header.modelName,r,x,!1);U._parentContainer=i,r._blockEntityCollection=!1,e.preserveSerializationData&&(1<=y.length&&U.setVerticesData(f.V.AdditionalUV1Kind,y[0],!1,4),2<=y.length&&U.setVerticesData(f.V.AdditionalUV2Kind,y[1],!1,4),3<=y.length&&U.setVerticesData(f.V.AdditionalUV3Kind,y[2],!1,4),4<=y.length&&U.setVerticesData(f.V.AdditionalUV4Kind,y[3],!1,4)),e.useSdef&&v&&(U.setVerticesData(f.V.MatricesSdefCKind,A,!1,3),U.setVerticesData(f.V.MatricesSdefR0Kind,T,!1,3),U.setVerticesData(f.V.MatricesSdefR1Kind,M,!1,3),U.setVerticesData(f.V.MatricesSdefRW0Kind,_,!1,3),U.setVerticesData(f.V.MatricesSdefRW1Kind,I,!1,3)),e.preserveSerializationData&&U.setVerticesData(f.V.EdgeScaleKind,w,!1,1),U.applyToMesh(S),a.push(U),d.push({map:E,isReferencedVertex:g}),c+=p.indexCount}}return s.endTask("Build Geometry"),s.invokeProgressEvent(),{meshes:o,geometries:a,indices:l,indexToSubmehIndexMaps:d}}async _buildMaterialAsync(e,t,n,r,i,s,o,a,l){let d;const h=new Array(t.textures.length);for(let e=0;e<h.length;++e)h[e]={noMipmap:!1,invertY:!0,samplingMode:void 0,imagePathIndex:e};const c=[];for(let e=0;e<r.length;++e)c.push([r[e]]);const u=new Promise((u=>{d=e.materialBuilder.buildMaterials(n.uniqueId,t.materials,h,t.textures,a,"file:"+e.pmFileId+"_",e.referenceFiles,c,r,s,o,i,this,(e=>{e.lengthComputable&&(l.setTaskProgressRatio("Texture Load",e.loaded/e.total,!0),l.invokeProgressEvent())}),(()=>u()))})),p=Array.isArray(d)?d:await d;for(let e=0;e<p.length;++e)r[e].material=p[e];return l.endTask("Build Material"),l.invokeProgressEvent(),{materials:p,multiMaterials:[],textureLoadPromise:u}}async _buildMorphAsync(e,t,n,r,i,o,a){const l=e.preserveSerializationData,d=new Int32Array(t.vertices.length).fill(-1),h=new Map,c=n.indices;{const e=t.materials;let n=0;for(let t=0;t<e.length;++t){const r=e[t].indexCount;for(let e=0;e<r;++e){const r=c[n+e];if(-1===d[r])d[r]=t;else if(-2===d[r]){const e=h.get(r);e.includes(t)||e.push(t)}else d[r]!==t&&(h.set(r,[d[r],t]),d[r]=-2)}n+=r}}const u=n.indexToSubmehIndexMaps,p=t.morphs,g=n.geometries,f=new Array(g.length);for(let e=0;e<f.length;++e)f[e]=[];let m=0,x=performance.now();for(let e=0;e<p.length;++e){const t=p[e],n=[],i=[];switch(t.type){case b.Morph.Type.GroupMorph:case b.Morph.Type.BoneMorph:case b.Morph.Type.MaterialMorph:o.push(t);break;case b.Morph.Type.VertexMorph:case b.Morph.Type.UvMorph:case b.Morph.Type.AdditionalUvMorph1:case b.Morph.Type.AdditionalUvMorph2:case b.Morph.Type.AdditionalUvMorph3:case b.Morph.Type.AdditionalUvMorph4:o.push({name:t.name,englishName:t.englishName,category:t.category,type:t.type,morphTargets:n,...l?{elements:i}:void 0});break;default:this.warn(`Unsupported morph type: ${t.type}`)}if(t.type!==b.Morph.Type.VertexMorph&&t.type!==b.Morph.Type.UvMorph&&t.type!==b.Morph.Type.AdditionalUvMorph1&&t.type!==b.Morph.Type.AdditionalUvMorph2&&t.type!==b.Morph.Type.AdditionalUvMorph3&&t.type!==b.Morph.Type.AdditionalUvMorph4)continue;const c=[];{const e=t.indices;for(let t=0;t<e.length;++t){const n=e[t],r=d[n];if(-1!==r)if(-2===r){const e=h.get(n);for(let t=0;t<e.length;++t){const n=e[t];c.includes(n)||c.push(n)}}else c.includes(r)||c.push(r)}if(t.type!==b.Morph.Type.AdditionalUvMorph1&&t.type!==b.Morph.Type.AdditionalUvMorph2&&t.type!==b.Morph.Type.AdditionalUvMorph3&&t.type!==b.Morph.Type.AdditionalUvMorph4)for(let e=0;e<c.length;++e){const i=new U.M(t.name,0,r);n.push(i),f[c[e]].push(i)}}if(t.type===b.Morph.Type.VertexMorph)for(let e=0;e<c.length;++e){const r=c[e],o=g[r],a=new Float32Array(o.getVerticesData(s.R.PositionKind)),d=t.indices,h=t.positions,p=u[r].map,f=u[r].isReferencedVertex;if(l){let e=0;for(let t=0;t<d.length;++t){if(0===f[d[t]])continue;const n=p[d[t]];a[3*n+0]+=h[3*t+0],a[3*n+1]+=h[3*t+1],a[3*n+2]+=h[3*t+2],e+=1}const t=new Int32Array(e),n=new Float32Array(3*e);for(let e=0,r=0;e<d.length;++e){if(0===f[d[e]])continue;const i=p[d[e]];t[r]=i,n[3*r+0]=h[3*e+0],n[3*r+1]=h[3*e+1],n[3*r+2]=h[3*e+2],r+=1}i.push({meshIndex:r,indices:t,offsets:n})}else for(let e=0;e<d.length;++e){if(0===f[d[e]])continue;const t=p[d[e]];a[3*t+0]+=h[3*e+0],a[3*t+1]+=h[3*e+1],a[3*t+2]+=h[3*e+2]}n[e].setPositions(a)}else if(t.type===b.Morph.Type.UvMorph)for(let e=0;e<c.length;++e){const r=c[e],o=g[r],a=new Float32Array(o.getVerticesData(s.R.UVKind)),d=t.indices,h=t.offsets,p=u[r].map,f=u[r].isReferencedVertex;if(l){let e=0;for(let t=0;t<d.length;++t){if(0===f[d[t]])continue;const n=p[d[t]];a[2*n+0]+=h[4*t+0],a[2*n+1]-=h[4*t+1],e+=1}const t=new Int32Array(e),n=new Float32Array(4*e);for(let e=0,r=0;e<d.length;++e){if(0===f[d[e]])continue;const i=p[d[e]];t[r]=i,n[4*r+0]=h[4*e+0],n[4*r+1]=-h[4*e+1],n[4*r+2]=h[4*e+2],n[4*r+3]=h[4*e+3],r+=1}i.push({meshIndex:r,indices:t,offsets:n})}else for(let e=0;e<d.length;++e){if(0===f[d[e]])continue;const t=p[d[e]];a[2*t+0]+=h[4*e+0],a[2*t+1]-=h[4*e+1]}const m=n[e];m.setPositions(o.getVerticesData(s.R.PositionKind)),m.setUVs(a)}else if(l)for(let e=0;e<c.length;++e){const n=c[e],r=u[n].map,s=u[n].isReferencedVertex,o=t.indices,a=t.offsets;let l=0;for(let e=0;e<o.length;++e)0!==s[o[e]]&&(l+=1);const d=new Int32Array(l),h=new Float32Array(4*l);for(let e=0,t=0;e<o.length;++e){if(0===s[o[e]])continue;const n=r[o[e]];d[t]=n,h[4*t+0]=a[4*e+0],h[4*t+1]=a[4*e+1],h[4*t+2]=a[4*e+2],h[4*t+3]=a[4*e+3],t+=1}i.push({meshIndex:n,indices:d,offsets:h})}m+=t.indices.length,100<performance.now()-x&&(a.setTaskProgress("Build Morph",m),a.invokeProgressEvent(),await R.S0.DelayAsync(0),x=performance.now())}a.endTask("Build Morph");const y=[],A=n.meshes;for(let e=0;e<f.length;++e){const t=f[e];if(0===t.length)continue;r._blockEntityCollection=!!i;const n=new D.j(r);n._parentContainer=i,r._blockEntityCollection=!1,n.enableNormalMorphing=!1,n.enableTangentMorphing=!1,n.enableUVMorphing=!1,n.areUpdatesFrozen=!0;for(let e=0;e<t.length;++e){const r=t[e];n.addTarget(r),r.hasUVs&&(n.enableUVMorphing=!0)}if(n.enableUVMorphing){const n=g[e].getVerticesData(s.R.UVKind);for(let e=0;e<t.length;++e){const r=t[e];r.hasUVs||r.setUVs(n)}}n.areUpdatesFrozen=!1,y.push(n),A[e].morphTargetManager=n}return y}}class xe extends me{constructor(e,t){super("pmd",S,e,t)}createPlugin(e){return new xe(e.mmdmodel,this)}async _parseFileAsync(e){return await E.ParseAsync(e,this).catch((e=>Promise.reject(e)))}}(0,I.cH)(new xe);class ye{_vertexIndexSize;_textureIndexSize;_materialIndexSize;_boneIndexSize;_morphIndexSize;_rigidBodyIndexSize;constructor(e,t,n,r,i,s){this._vertexIndexSize=e,this._textureIndexSize=t,this._materialIndexSize=n,this._boneIndexSize=r,this._morphIndexSize=i,this._rigidBodyIndexSize=s}getVertexIndex(e){switch(this._vertexIndexSize){case 1:return e.getUint8();case 2:return e.getUint16();case 4:return e.getInt32();default:throw new Error(`Invalid vertexIndexSize: ${this._vertexIndexSize}`)}}_getNonVertexIndex(e,t){switch(t){case 1:return e.getInt8();case 2:return e.getInt16();case 4:return e.getInt32();default:throw new Error(`Invalid indexSize: ${t}`)}}getTextureIndex(e){return this._getNonVertexIndex(e,this._textureIndexSize)}getMaterialIndex(e){return this._getNonVertexIndex(e,this._materialIndexSize)}getBoneIndex(e){return this._getNonVertexIndex(e,this._boneIndexSize)}getMorphIndex(e){return this._getNonVertexIndex(e,this._morphIndexSize)}getRigidBodyIndex(e){return this._getNonVertexIndex(e,this._rigidBodyIndexSize)}}class Ae{constructor(){}static async ParseAsync(e,t=new v){const n=new w(e),r=this._ParseHeader(n,t),i=new ye(r.vertexIndexSize,r.textureIndexSize,r.materialIndexSize,r.boneIndexSize,r.morphIndexSize,r.rigidBodyIndexSize),s=await this._ParseVerticesAsync(n,i,r),o=this._ParseIndices(n,i,r),a=this._ParseTextures(n),l=this._ParseMaterials(n,i),d=this._ParseBones(n,i),h=this._ParseMorphs(n,i),c=this._ParseDisplayFrames(n,i),u=this._ParseRigidBodies(n,i),p=this._ParseJoints(n,i),g=r.version<=2?[]:this._ParseSoftBodies(n,i,r);return n.bytesAvailable>0&&t.warn(`There are ${n.bytesAvailable} bytes left after parsing`),{header:r,vertices:s,indices:o,textures:a,materials:l,bones:d,morphs:h,displayFrames:c,rigidBodies:u,joints:p,softBodies:g}}static _ParseHeader(e,t){if(e.bytesAvailable<17)throw new RangeError("is not pmx file");const n=e.getSignatureString(3);if("PMX"!==n)throw new RangeError("is not pmx file");e.getInt8();const r=e.getFloat32(),i=e.getUint8(),s=e.getUint8();e.initializeTextDecoder(s===b.Header.Encoding.Utf8?"utf-8":"utf-16le");const o=e.getUint8(),a=e.getUint8(),l=e.getUint8(),d=e.getUint8(),h=e.getUint8(),c=e.getUint8(),u=e.getUint8();if(i<8)throw new Error(`Invalid globalsCount: ${i}`);if(8<i){t.warn(`globalsCount is greater than 8: ${i} files may be corrupted or higher version`);for(let t=8;t<i;++t)e.getUint8()}return{signature:n,version:r,encoding:s,additionalVec4Count:o,vertexIndexSize:a,textureIndexSize:l,materialIndexSize:d,boneIndexSize:h,morphIndexSize:c,rigidBodyIndexSize:u,modelName:e.getDecoderString(e.getInt32(),!1),englishModelName:e.getDecoderString(e.getInt32(),!1),comment:e.getDecoderString(e.getInt32(),!1),englishComment:e.getDecoderString(e.getInt32(),!1)}}static async _ParseVerticesAsync(e,t,n){const r=e.getInt32(),i=[];let s=performance.now();for(let o=0;o<r;++o){const r=e.getFloat32Tuple(3),a=e.getFloat32Tuple(3),l=e.getFloat32Tuple(2),d=[];for(let t=0;t<n.additionalVec4Count;++t)d.push(e.getFloat32Tuple(4));const h=e.getUint8();let c;switch(h){case b.Vertex.BoneWeightType.Bdef1:c={boneIndices:t.getBoneIndex(e),boneWeights:null};break;case b.Vertex.BoneWeightType.Bdef2:c={boneIndices:[t.getBoneIndex(e),t.getBoneIndex(e)],boneWeights:e.getFloat32()};break;case b.Vertex.BoneWeightType.Bdef4:c={boneIndices:[t.getBoneIndex(e),t.getBoneIndex(e),t.getBoneIndex(e),t.getBoneIndex(e)],boneWeights:[e.getFloat32(),e.getFloat32(),e.getFloat32(),e.getFloat32()]};break;case b.Vertex.BoneWeightType.Sdef:c={boneIndices:[t.getBoneIndex(e),t.getBoneIndex(e)],boneWeights:{boneWeight0:e.getFloat32(),c:e.getFloat32Tuple(3),r0:e.getFloat32Tuple(3),r1:e.getFloat32Tuple(3)}};break;case b.Vertex.BoneWeightType.Qdef:c={boneIndices:[t.getBoneIndex(e),t.getBoneIndex(e),t.getBoneIndex(e),t.getBoneIndex(e)],boneWeights:[e.getFloat32(),e.getFloat32(),e.getFloat32(),e.getFloat32()]};break;default:throw new Error(`Invalid weightType: ${h}`)}const u=e.getFloat32();i.push({position:r,normal:a,uv:l,additionalVec4:d,weightType:h,boneWeight:c,edgeScale:u}),o%1e4==0&&100<performance.now()-s&&(await new Promise((e=>setTimeout(e,0))),s=performance.now())}return i}static _ParseIndices(e,t,n){const r=e.getInt32(),i=new ArrayBuffer(r*n.vertexIndexSize);let s;switch(n.vertexIndexSize){case 1:s=new Uint8Array(i);break;case 2:s=new Uint16Array(i);break;case 4:s=new Int32Array(i);break;default:throw new Error(`Invalid vertexIndexSize: ${n.vertexIndexSize}`)}for(let n=0;n<r;++n)s[n]=t.getVertexIndex(e);return s}static _ParseTextures(e){const t=e.getInt32(),n=[];for(let r=0;r<t;++r){const t=e.getDecoderString(e.getInt32(),!1);n.push(t)}return n}static _ParseMaterials(e,t){const n=e.getInt32(),r=[];for(let i=0;i<n;++i){const n=e.getDecoderString(e.getInt32(),!1),i=e.getDecoderString(e.getInt32(),!1),s=e.getFloat32Tuple(4),o=e.getFloat32Tuple(3),a=e.getFloat32(),l=e.getFloat32Tuple(3),d=e.getUint8(),h=e.getFloat32Tuple(4),c=e.getFloat32(),u=t.getTextureIndex(e),p=t.getTextureIndex(e),g=e.getUint8(),f=1===e.getUint8(),m={name:n,englishName:i,diffuse:s,specular:o,shininess:a,ambient:l,flag:d,edgeColor:h,edgeSize:c,textureIndex:u,sphereTextureIndex:p,sphereTextureMode:g,isSharedToonTexture:f,toonTextureIndex:f?e.getUint8():t.getTextureIndex(e),comment:e.getDecoderString(e.getInt32(),!1),indexCount:e.getInt32()};r.push(m)}return r}static _ParseBones(e,t){const n=e.getInt32(),r=[];for(let i=0;i<n;++i){const n=e.getDecoderString(e.getInt32(),!1),i=e.getDecoderString(e.getInt32(),!1),s=e.getFloat32Tuple(3),o=t.getBoneIndex(e),a=e.getInt32(),l=e.getUint16();let d,h,c,u,p,g;if(d=l&b.Bone.Flag.UseBoneIndexAsTailPosition?t.getBoneIndex(e):e.getFloat32Tuple(3),(l&b.Bone.Flag.HasAppendMove||l&b.Bone.Flag.HasAppendRotate)&&(h={parentIndex:t.getBoneIndex(e),ratio:e.getFloat32()}),l&b.Bone.Flag.HasAxisLimit&&(c=e.getFloat32Tuple(3)),l&b.Bone.Flag.HasLocalVector&&(u={x:e.getFloat32Tuple(3),z:e.getFloat32Tuple(3)}),l&b.Bone.Flag.IsExternalParentTransformed&&(p=e.getInt32()),l&b.Bone.Flag.IsIkEnabled){const n=t.getBoneIndex(e),r=e.getInt32(),i=e.getFloat32(),s=[],o=e.getInt32();for(let n=0;n<o;++n){const n={target:t.getBoneIndex(e),limitation:1===e.getUint8()?{minimumAngle:e.getFloat32Tuple(3),maximumAngle:e.getFloat32Tuple(3)}:void 0};s.push(n)}g={target:n,iteration:r,rotationConstraint:i,links:s}}const f={name:n,englishName:i,position:s,parentBoneIndex:o,transformOrder:a,flag:l,tailPosition:d,appendTransform:h,axisLimit:c,localVector:u,externalParentTransform:p,ik:g};r.push(f)}return r}static _ParseMorphs(e,t){const n=e.getInt32(),r=[];for(let i=0;i<n;++i){const n=e.getDecoderString(e.getInt32(),!1),i=e.getDecoderString(e.getInt32(),!1),s=e.getInt8(),o=e.getInt8();let a={name:n,englishName:i,category:s,type:o};const l=e.getInt32();switch(o){case b.Morph.Type.GroupMorph:{const n=new Int32Array(l),r=new Float32Array(l);for(let i=0;i<l;++i)n[i]=t.getMorphIndex(e),r[i]=e.getFloat32();a={...a,indices:n,ratios:r}}break;case b.Morph.Type.VertexMorph:{const n=new Int32Array(l),r=new Float32Array(3*l);for(let i=0;i<l;++i)n[i]=t.getVertexIndex(e),r[3*i+0]=e.getFloat32(),r[3*i+1]=e.getFloat32(),r[3*i+2]=e.getFloat32();a={...a,indices:n,positions:r}}break;case b.Morph.Type.BoneMorph:{const n=new Int32Array(l),r=new Float32Array(3*l),i=new Float32Array(4*l);for(let s=0;s<l;++s)n[s]=t.getBoneIndex(e),r[3*s+0]=e.getFloat32(),r[3*s+1]=e.getFloat32(),r[3*s+2]=e.getFloat32(),i[4*s+0]=e.getFloat32(),i[4*s+1]=e.getFloat32(),i[4*s+2]=e.getFloat32(),i[4*s+3]=e.getFloat32();a={...a,indices:n,positions:r,rotations:i}}break;case b.Morph.Type.UvMorph:case b.Morph.Type.AdditionalUvMorph1:case b.Morph.Type.AdditionalUvMorph2:case b.Morph.Type.AdditionalUvMorph3:case b.Morph.Type.AdditionalUvMorph4:{const n=new Int32Array(l),r=new Float32Array(4*l);for(let i=0;i<l;++i)n[i]=t.getVertexIndex(e),r[4*i+0]=e.getFloat32(),r[4*i+1]=e.getFloat32(),r[4*i+2]=e.getFloat32(),r[4*i+3]=e.getFloat32();a={...a,indices:n,offsets:r}}break;case b.Morph.Type.MaterialMorph:{const n=[];for(let r=0;r<l;++r){const r={index:t.getMaterialIndex(e),type:e.getUint8(),diffuse:e.getFloat32Tuple(4),specular:e.getFloat32Tuple(3),shininess:e.getFloat32(),ambient:e.getFloat32Tuple(3),edgeColor:e.getFloat32Tuple(4),edgeSize:e.getFloat32(),textureColor:e.getFloat32Tuple(4),sphereTextureColor:e.getFloat32Tuple(4),toonTextureColor:e.getFloat32Tuple(4)};n.push(r)}a={...a,elements:n}}break;case b.Morph.Type.FlipMorph:{const n=new Int32Array(l),r=new Float32Array(l);for(let i=0;i<l;++i)n[i]=t.getMorphIndex(e),r[i]=e.getFloat32();a={...a,indices:n,ratios:r}}break;case b.Morph.Type.ImpulseMorph:{const n=new Int32Array(l),r=new Array(l),i=new Float32Array(3*l),s=new Float32Array(3*l);for(let o=0;o<l;++o)n[o]=t.getRigidBodyIndex(e),r[o]=1===e.getUint8(),i[3*o+0]=e.getFloat32(),i[3*o+1]=e.getFloat32(),i[3*o+2]=e.getFloat32(),s[3*o+0]=e.getFloat32(),s[3*o+1]=e.getFloat32(),s[3*o+2]=e.getFloat32();a={...a,indices:n,isLocals:r,velocities:i,torques:s}}break;default:throw new Error(`Unknown morph type: ${o}`)}r.push(a)}return r}static _ParseDisplayFrames(e,t){const n=e.getInt32(),r=[];for(let i=0;i<n;++i){const n=e.getDecoderString(e.getInt32(),!1),i=e.getDecoderString(e.getInt32(),!1),s=1===e.getUint8(),o=e.getInt32(),a=[];for(let n=0;n<o;++n){const n=e.getUint8(),r={type:n,index:n===b.DisplayFrame.FrameData.FrameType.Bone?t.getBoneIndex(e):t.getMorphIndex(e)};a.push(r)}const l={name:n,englishName:i,isSpecialFrame:s,frames:a};r.push(l)}return r}static _ParseRigidBodies(e,t){const n=e.getInt32(),r=[];for(let i=0;i<n;++i){const n={name:e.getDecoderString(e.getInt32(),!1),englishName:e.getDecoderString(e.getInt32(),!1),boneIndex:t.getBoneIndex(e),collisionGroup:e.getUint8(),collisionMask:e.getUint16(),shapeType:e.getUint8(),shapeSize:e.getFloat32Tuple(3),shapePosition:e.getFloat32Tuple(3),shapeRotation:e.getFloat32Tuple(3),mass:e.getFloat32(),linearDamping:e.getFloat32(),angularDamping:e.getFloat32(),repulsion:e.getFloat32(),friction:e.getFloat32(),physicsMode:e.getUint8()};r.push(n)}return r}static _ParseJoints(e,t){const n=e.getInt32(),r=[];for(let i=0;i<n;++i){const n={name:e.getDecoderString(e.getInt32(),!1),englishName:e.getDecoderString(e.getInt32(),!1),type:e.getUint8(),rigidbodyIndexA:t.getRigidBodyIndex(e),rigidbodyIndexB:t.getRigidBodyIndex(e),position:e.getFloat32Tuple(3),rotation:e.getFloat32Tuple(3),positionMin:e.getFloat32Tuple(3),positionMax:e.getFloat32Tuple(3),rotationMin:e.getFloat32Tuple(3),rotationMax:e.getFloat32Tuple(3),springPosition:e.getFloat32Tuple(3),springRotation:e.getFloat32Tuple(3)};r.push(n)}return r}static _ParseSoftBodies(e,t,n){const r=e.getInt32(),i=[];for(let s=0;s<r;++s){const r=e.getDecoderString(e.getInt32(),!1),s=e.getDecoderString(e.getInt32(),!1),o=e.getUint8(),a=t.getMaterialIndex(e),l=e.getUint8(),d=e.getUint16(),h=e.getUint8(),c=e.getInt32(),u=e.getInt32(),p=e.getFloat32(),g=e.getFloat32(),f=e.getInt32(),m={vcf:e.getFloat32(),dp:e.getFloat32(),dg:e.getFloat32(),lf:e.getFloat32(),pr:e.getFloat32(),vc:e.getFloat32(),df:e.getFloat32(),mt:e.getFloat32(),chr:e.getFloat32(),khr:e.getFloat32(),shr:e.getFloat32(),ahr:e.getFloat32()},x={srhrCl:e.getFloat32(),skhrCl:e.getFloat32(),sshrCl:e.getFloat32(),srSpltCl:e.getFloat32(),skSpltCl:e.getFloat32(),ssSpltCl:e.getFloat32()},y={vIt:e.getInt32(),pIt:e.getInt32(),dIt:e.getInt32(),cIt:e.getInt32()},A={lst:e.getInt32(),ast:e.getInt32(),vst:e.getInt32()},T=e.getInt32(),M=[];for(let n=0;n<T;++n){const n={rigidbodyIndex:t.getRigidBodyIndex(e),vertexIndex:t.getVertexIndex(e),isNearMode:0!==e.getUint8()};M.push(n)}const _=e.getInt32(),b=new ArrayBuffer(_*n.vertexIndexSize);let I;switch(n.vertexIndexSize){case 1:I=new Uint8Array(b);break;case 2:I=new Uint16Array(b);break;case 4:I=new Int32Array(b);break;default:throw new Error(`Invalid vertexIndexSize: ${n.vertexIndexSize}`)}for(let n=0;n<_;++n)I[n]=t.getVertexIndex(e);const v={name:r,englishName:s,type:o,materialIndex:a,collisionGroup:l,collisionMask:d,flags:h,bLinkDistance:c,clusterCount:u,totalMass:p,collisionMargin:g,aeroModel:f,config:m,cluster:x,iteration:y,material:A,anchors:M,vertexPins:I};i.push(v)}return i}}const Te={".pmx":{isBinary:!0}};class Me extends me{constructor(e,t){super("pmx",Te,e,t)}createPlugin(e){return new Me(e.mmdmodel,this)}async _parseFileAsync(e){return await Ae.ParseAsync(e,this).catch((e=>Promise.reject(e)))}}(0,I.cH)(new Me);var _e,be,Ie,ve=n(9057),we=n(5581),Ee=n(1513),Se=n(8595),Ce=n(8529),Fe=n(3770);!function(e){e.isMmdMesh=function(e){return!(null===e.metadata||!e.metadata.isMmdModel)},e.isMmdSkinnedMesh=function(e){return!(null===e.metadata||!e.metadata.isMmdModel)&&null!==e.metadata.skeleton}}(_e||(_e={})),function(e){e.isSerializationMetadata=function(e){return!0===e.containsSerializationData}}(be||(be={}));class Be{_dataView;_encoder;_offset;constructor(e){this._dataView=new DataView(e),this._encoder=new TextEncoder,this._offset=0}get offset(){return this._offset}set offset(e){this._offset=e}setUint8(e){this._dataView.setUint8(this._offset,e),this._offset+=1}setUint8Array(e){const t=this._dataView;for(let n=0;n<e.length;++n)t.setUint8(this._offset,e[n]),this._offset+=1}setInt8(e){this._dataView.setInt8(this._offset,e),this._offset+=1}setInt8Array(e){const t=this._dataView;for(let n=0;n<e.length;++n)t.setInt8(this._offset,e[n]),this._offset+=1}setUint16(e){this._dataView.setUint16(this._offset,e,!0),this._offset+=2}setUint16Array(e){const t=this._dataView;for(let n=0;n<e.length;++n)t.setUint16(this._offset,e[n],!0),this._offset+=2}setUint32(e){this._dataView.setUint32(this._offset,e,!0),this._offset+=4}setUint32Array(e){const t=this._dataView;for(let n=0;n<e.length;++n)t.setUint32(this._offset,e[n],!0),this._offset+=4}setInt32(e){this._dataView.setInt32(this._offset,e,!0),this._offset+=4}setInt32Array(e){const t=this._dataView;for(let n=0;n<e.length;++n)t.setInt32(this._offset,e[n],!0),this._offset+=4}setFloat32(e){this._dataView.setFloat32(this._offset,e,!0),this._offset+=4}setFloat32Array(e){const t=this._dataView;for(let n=0;n<e.length;++n)t.setFloat32(this._offset,e[n],!0),this._offset+=4}setString(e){const t=this._dataView,n=this._encoder.encode(e);t.setUint32(this._offset,n.length,!0),this._offset+=4;for(let e=0;e<n.length;++e)t.setUint8(this._offset,n[e]),this._offset+=1}get bytesAvailable(){return this._dataView.byteLength-this._offset}static Padding(e,t){return e%t==0?0:t-e%t}}!function(e){let t,n,r;!function(e){let t,n,r;!function(e){e[e.IsSkinnedMesh=1]="IsSkinnedMesh"}(t=e.MeshType||(e.MeshType={})),function(e){e[e.HasSdef=1]="HasSdef",e[e.IsIndexed=2]="IsIndexed",e[e.HasEdgeScale=4]="HasEdgeScale"}(n=e.GeometryType||(e.GeometryType={})),function(e){e[e.Int32=0]="Int32",e[e.Uint32=1]="Uint32",e[e.Uint16=2]="Uint16"}(r=e.IndexElementType||(e.IndexElementType={}))}(t=e.Geometry||(e.Geometry={})),function(e){let t;!function(e){e[e.HasMimeType=1]="HasMimeType"}(t=e.Flag||(e.Flag={}))}(n=e.Image||(e.Image={})),function(e){let t;!function(e){e[e.NoMipmap=1]="NoMipmap",e[e.InvertY=2]="InvertY"}(t=e.Flag||(e.Flag={}))}(r=e.Texture||(e.Texture={}))}(Ie||(Ie={}));class Re{_loggingEnabled;log;warn;error;constructor(){this._loggingEnabled=!0,this.log=this._logDisabled,this.warn=this._warnDisabled,this.error=this._errorDisabled}convert(e,t={}){if(!_e.isMmdMesh(e))throw new Error(`${e.name} is not MmdMesh`);const{includeSkinningData:n=!0,includeMorphData:r=!0,translucentMaterials:i=[],alphaEvaluateResults:o=[]}=t,a=e.metadata,l=be.isSerializationMetadata(a);n&&null===a.skeleton&&this.log("MmdMesh has no skeleton. Skinning data will not be included");const d=[],h=new Int32Array(a.bones.length).fill(-1);let c=-1;const u=a.skeleton?.bones??[];for(let e=0;e<u.length;++e)c=Math.max(c,u[e].getIndex());const p=new Int32Array(c+1).fill(-1);if(n&&null!==a.skeleton){const e=a.bones,t=new Map;{const n=new Map;for(let e=0;e<u.length;++e){const t=u[e];let r=n.get(t.name);void 0===r&&(r=[],n.set(t.name,r)),r.push({index:e,value:t})}for(let r=0;r<e.length;++r){const i=e[r],s=n.get(i.name);if(void 0!==s)if(1===s.length)t.set(i,s[0].value);else{let e;for(let t=0;t<s.length;++t)if(s[t].index===r){e=s[t].value;break}void 0!==e&&t.set(i,e)}}}const n=new Map;{const t=new Map;for(let n=0;n<e.length;++n){const r=e[n];let i=t.get(r.name);void 0===i&&(i=[],t.set(r.name,i)),i.push({index:n,value:r})}for(let e=0;e<u.length;++e){const r=u[e],i=t.get(r.name);if(void 0!==i)if(1===i.length)n.set(r,i[0].value);else{let t;for(let n=0;n<i.length;++n)if(i[n].index===e){t=i[n].value;break}void 0!==t&&n.set(r,t)}}}const r=new Map;for(let t=0;t<e.length;++t){const n=e[t];let i=r.get(e[n.parentBoneIndex]);void 0===i&&0<=n.parentBoneIndex&&n.parentBoneIndex<e.length&&(i=[],r.set(e[n.parentBoneIndex],i)),i?.push(n)}const i=new Map;for(let e=0;e<u.length;++e){if(null!==u[e].getParent())continue;const t=[u[e]];for(i.set(u[e],u[e].getRestMatrix());t.length>0;){const e=t.pop(),n=i.get(e),r=e.children;for(let e=0;e<r.length;++e){const s=r[e];i.set(s,s.getRestMatrix().multiply(n)),t.push(s)}}}const s=new Map;for(let o=0;o<e.length;++o){const a=e[o];let l=t.get(a);const c=[],u=e=>{const t=e.children;for(let r=0;r<t.length;++r){const i=t[r],o=n.get(i);void 0===o?(c.push(e),u(i)):s.has(o)||s.set(o,d.length+c.length)}};if(void 0!==l)u(l);else{const e=r.get(a);if(void 0!==e)for(let t=0;t<e.length;++t){const n=e[t];s.set(n,d.length+c.length)}}const g=e=>{const n=r.get(e);if(void 0!==n)for(let e=0;e<n.length;++e){const r=n[e];let i=t.get(r);if(void 0!==i)return i;if(i=g(r),void 0!==i)return i}};if(void 0===l&&(l=g(a)),void 0===l){let n=e[a.parentBoneIndex];for(;void 0!==n&&(l=t.get(n),void 0===l);)n=e[n.parentBoneIndex]}const f=a.name,m=a.englishName,x=void 0!==l?i.get(l).getTranslation().asArray():[0,0,0],y=-1,A=a.transformOrder,T=a.tailPosition??-2,M=a.appendTransform,_=a.axisLimit,I=a.localVector,v=a.externalParentTransform,w=a.ik;let E=0;E=a.flag?a.flag:b.Bone.Flag.IsRotatable|b.Bone.Flag.IsMovable|b.Bone.Flag.IsVisible|b.Bone.Flag.IsControllable,E&=(Array.isArray(T)?~b.Bone.Flag.UseBoneIndexAsTailPosition:-1)&(M?-1:~b.Bone.Flag.HasAppendRotate|~b.Bone.Flag.HasAppendMove)&(_?-1:~b.Bone.Flag.HasAxisLimit)&(I?-1:~b.Bone.Flag.HasLocalVector)&(v?-1:~b.Bone.Flag.IsExternalParentTransformed)&(w?-1:~b.Bone.Flag.IsIkEnabled),E|=(Array.isArray(T)?0:b.Bone.Flag.UseBoneIndexAsTailPosition)|(M?b.Bone.Flag.HasAppendRotate|b.Bone.Flag.HasAppendMove:0)|(_?b.Bone.Flag.HasAxisLimit:0)|(I?b.Bone.Flag.HasLocalVector:0)|(v?b.Bone.Flag.IsExternalParentTransformed:0)|(w?b.Bone.Flag.IsIkEnabled:0);const S={name:f,englishName:m,position:x,parentBoneIndex:y,transformOrder:A,flag:E,tailPosition:T,appendTransform:M,axisLimit:_,localVector:I,externalParentTransform:v,ik:w},C=h[o]=d.length;void 0!==l&&(p[l.getIndex()]=C),d.push(S);const F=b.Bone.Flag.UseBoneIndexAsTailPosition|b.Bone.Flag.IsRotatable|b.Bone.Flag.IsVisible|b.Bone.Flag.IsControllable;for(let e=0;e<c.length;++e){const t=c[e];p[t.getIndex()]=d.length;let r=-1;const s=t.getParent();null!==s&&(r=n.get(s)===a?C:p[s.getIndex()]),d.push({name:t.name,englishName:"",position:i.get(t).getTranslation().asArray(),parentBoneIndex:r,transformOrder:0,flag:F,tailPosition:r,appendTransform:void 0,axisLimit:void 0,localVector:void 0,externalParentTransform:void 0,ik:void 0})}}for(let t=0;t<e.length;++t){const n=e[t],r=d[h[t]],i=r.parentBoneIndex=s.get(n)??-1;-2===r.tailPosition?r.tailPosition=i:"number"==typeof r.tailPosition&&0<=r.tailPosition&&r.tailPosition<e.length&&(r.tailPosition=h[r.tailPosition]);const o=r.appendTransform;void 0!==o&&(r.appendTransform={parentIndex:h[o.parentIndex]??o.parentIndex,ratio:o.ratio});const a=r.ik;if(void 0!==a){const e=[];r.ik={target:h[a.target]??a.target,iteration:a.iteration,rotationConstraint:a.rotationConstraint,links:e};const t=a.links;for(let n=0;n<t.length;++n){const r=t[n];e.push({target:h[r.target]??r.target,limitation:r.limitation})}}}}const g=[],m=new Map;{const e=a.meshes;for(let t=0;t<e.length;++t){const n=e[t];if(null===n.geometry){this.warn(`mesh ${n.name} has no geometry. skippping`);continue}const r=n.geometry;null!==r.getVerticesData(s.R.PositionKind)?null!==r.getVerticesData(s.R.NormalKind)?null!==r.getVerticesData(s.R.UVKind)?n.isUnIndexed||null!==r.getIndices()?null===a.skeleton||a.skeleton===n.skeleton?(m.set(t,g.length),g.push(n)):this.warn(`mesh ${n.name} has different skeleton. skippping`):this.warn(`mesh ${n.name} has no indices data. skippping`):this.warn(`mesh ${n.name} has no uv data. skippping`):this.warn(`mesh ${n.name} has no normal data. skippping`):this.warn(`mesh ${n.name} has no position data. skippping`)}}const x=[],y=[];{const e=new Set;for(let t=0;t<g.length;++t){const n=g[t].material;if(null===n)continue;const r=n.subMaterials??[n];for(let t=0;t<r.length;++t){const n=r[t];if(null!==n&&(n.diffuseTexture?e.add(n.diffuseTexture):n.albedoTexture&&e.add(n.albedoTexture),n.sphereTexture&&e.add(n.sphereTexture),n.toonTexture)){const t=n.toonTexture.name;t.startsWith("file:shared_toon_texture_")&&t.length<=27&&!isNaN(Number(t.substring(25)))||e.add(n.toonTexture)}}}const t=l?a.textureNameMap:null;null===t&&this.warn("metadata.textureNameMap is not defined. texture names will be fallback to converted string by loader");const n=new Map,r=new Map;for(const i of e){let e=null;const s=i._buffer;s instanceof ArrayBuffer?e=new Uint8Array(s):null==s?this.warn(`texture ${i.name} has no texture buffer. make sure load model with materialBuilder.deleteTextureBufferAfterLoad = false`):s.buffer instanceof ArrayBuffer?e=new Uint8Array(s.buffer,s.byteOffset,s.byteLength):this.warn(`texture ${i.name} has unsupported type of texture buffer. only ArrayBuffer and TypedArray is supported`);const o=(i.noMipmap?Ie.Texture.Flag.NoMipmap:0)|(i.invertY?Ie.Texture.Flag.InvertY:0);let a;if(null!==e){let s=r.get(e.buffer);void 0===s&&(s=r.size,r.set(e.buffer,s));const o=`${s}_${e.byteOffset}_${e.byteLength}`;if(a=n.get(o),void 0===a){a=x.length,n.set(o,a);let r=t?.get(i);void 0===r&&(this.warn(`texture ${i.name} has no name in textureNameMap. falling back to converted string by loader`),r=i.name),x.push({relativePath:r,mimeType:i.mimeType,buffer:e})}}y.push({flag:o,samplingMode:i.samplingMode,imageIndex:a??-1,texture:i})}}const A=[],T=new Map;{const e=new Map;{const t=a.materials;for(let n=0;n<t.length;++n){const r=t[n];e.set(r,n)}}const t=new Map;{const e=a.materials,n=l?a.materialsMetadata:null;if(null!==n)for(let r=0;r<e.length;++r){const i=e[r],s=n[r];t.has(i)||void 0!==s&&t.set(i,s)}}let n=!1;const r=new Map;for(let s=0;s<g.length;++s){const a=g[s],l=[];{const e=a.material?.subMaterials??[a.material],t=a.subMeshes;for(let n=0;n<t.length;++n){const r=e[t[n].materialIndex];l.push(r)}}for(let s=0;s<l.length;++s){const d=l[s];if(null===d){if(n)this.warn(`mesh ${a.name} has no material. using default material metadata`);else{n=!0,this.warn(`mesh ${a.name} has no material. adding default material metadata`);const e={name:"default",englishName:"default",diffuse:[1,1,1,1],specular:[0,0,0],shininess:0,ambient:[0,0,0],evaluatedTransparency:0,flag:0,edgeColor:[0,0,0,1],edgeSize:0,textureIndex:-1,sphereTextureIndex:-1,sphereTextureMode:b.Material.SphereTextureMode.Off,isSharedToonTexture:!1,toonTextureIndex:-1,comment:"",linkedMaterial:null};A.push(e)}continue}const h=r.get(d),c=e.get(d);if(void 0===c)this.warn(`mesh ${a.name} has material which is not included in model metadata`);else if(void 0!==h)T.set(c,h);else{T.set(c,A.length),r.set(d,A.length);const e=t.get(d);void 0===e&&this.log(`mesh ${a.name} has no additional material metadata`);const n=d.name??"",s=e?.englishName??"",l=d.diffuseColor?.asArray()??[1,1,1,1];l.length=4,l[3]=d.alpha??1;const h=d.specularColor?.asArray()??d.reflectivityColor?.asArray()??[0,0,0];h.length=3;const u=d.specularPower??0,p=d.ambientColor?.asArray()??[0,0,0];p.length=3;const g=(3&+(i[c]??-1))<<4|(15&(o[c]??-1))<<0,f=(!1===d.backFaceCulling?b.Material.Flag.IsDoubleSided:0)|(d.renderOutline?b.Material.Flag.EnabledToonEdge:0),m=d.outlineColor?.asArray()??[0,0,0];m.length=4,m[3]=d.outlineAlpha??0;const x=d.outlineWidth??0,M=d.diffuseTexture??d.albedoTexture,_=M?y.findIndex((e=>e.texture===M)):-1,I=d.sphereTexture,v=I?y.findIndex((e=>e.texture===I)):-1,w=d.sphereTextureBlendMode??b.Material.SphereTextureMode.Off,E=d.toonTexture,S=!!E&&E.name.startsWith("file:shared_toon_texture_")&&E.name.length<=27&&!isNaN(Number(E.name.substring(25)));let C;C=S?Number(E.name.substring(25))-1:E?y.findIndex((e=>e.texture===E)):-1;const F={name:n,englishName:s,diffuse:l,specular:h,shininess:u,ambient:p,evaluatedTransparency:g,flag:f,edgeColor:m,edgeSize:x,textureIndex:_,sphereTextureIndex:v,sphereTextureMode:w,isSharedToonTexture:S,toonTextureIndex:C,comment:e?.comment??"",linkedMaterial:d};A.push(F)}}}}const M=new Array(a.morphs.length).fill(null);for(let e=0;e<M.length;++e)M[e]=[];if(r)if(l){const e=a.morphs;for(let t=0;t<e.length;++t){const n=e[t];switch(n.type){case b.Morph.Type.VertexMorph:case b.Morph.Type.UvMorph:case b.Morph.Type.AdditionalUvMorph1:case b.Morph.Type.AdditionalUvMorph2:case b.Morph.Type.AdditionalUvMorph3:case b.Morph.Type.AdditionalUvMorph4:{const e=[],r=n.elements;for(let t=0;t<r.length;++t){const i=r[t],s=m.get(i.meshIndex);void 0!==s?e.push({meshIndex:s,indices:i.indices,offsets:i.offsets}):this.warn(`morph ${n.name} has invalid mesh. skipping`)}M[t]=e}}}}else{this.warn("metadata.morphsMetadata is not defined. UV morphs will be lossy converted");const e=a.morphs;for(let t=0;t<e.length;++t){const n=e[t];let r=!1;switch(n.type){case b.Morph.Type.VertexMorph:case b.Morph.Type.UvMorph:case b.Morph.Type.AdditionalUvMorph1:case b.Morph.Type.AdditionalUvMorph2:case b.Morph.Type.AdditionalUvMorph3:case b.Morph.Type.AdditionalUvMorph4:r=!0}if(!r)continue;const i=M[t]=[],o=n.morphTargets;for(let e=0;e<o.length;++e){let t=-1;const r=o[e];e:for(let e=0;e<g.length;++e){const n=g[e].morphTargetManager;if(null===n)continue;const i=n.numTargets;for(let s=0;s<i;++s)if(n.getTarget(s)===r){t=e;break e}}if(-1===t){this.warn(`morph ${n.name} has no target mesh. skipping`);continue}let a,l,d=0;if(n.type===b.Morph.Type.VertexMorph){const e=g[t].geometry.getVerticesData(s.R.PositionKind),i=r.getPositions();if(null===i){this.warn(`morph ${n.name} has no positions data. skipping`);continue}if(e.length!==i.length){this.warn(`morph ${n.name} has different number of positions. skipping`);continue}for(let t=0;t<e.length;t+=3)e[t+0]===i[t+0]&&e[t+1]===i[t+1]&&e[t+2]===i[t+2]||(d+=1);a=new Int32Array(d),l=new Float32Array(3*d);const o=e.length/3;for(let t=0,n=0;t<o;++t)e[3*t+0]===i[3*t+0]&&e[3*t+1]===i[3*t+1]&&e[3*t+2]===i[3*t+2]||(a[n]=t,l[3*n+0]=i[3*t+0]-e[3*t+0],l[3*n+1]=i[3*t+1]-e[3*t+1],l[3*n+2]=i[3*t+2]-e[3*t+2],n+=1)}else{const e=g[t].geometry.getVerticesData(s.R.UVKind),i=r.getUVs();if(null===i){this.warn(`morph ${n.name} has no uvs data. skipping`);continue}if(e.length!==i.length){this.warn(`morph ${n.name} has different number of uvs. skipping`);continue}for(let t=0;t<e.length;t+=2)e[t+0]===i[t+0]&&e[t+1]===i[t+1]||(d+=1);a=new Int32Array(d),l=new Float32Array(4*d);const o=e.length/2;for(let t=0,n=0;t<o;++t)e[2*t+0]===i[2*t+0]&&e[2*t+1]===i[2*t+1]||(a[n]=t,l[4*n+0]=i[2*t+0]-e[2*t+0],l[4*n+1]=i[2*t+1]-e[2*t+1],n+=1)}i.push({meshIndex:t,indices:a,offsets:l})}}}const _=new TextEncoder;let I=7;{const e=a.header;I+=4+_.encode(e.modelName).length,I+=4+_.encode(e.englishModelName).length,I+=4+_.encode(e.comment).length,I+=4+_.encode(e.englishComment).length,I+=1,I+=4;for(let e=0;e<g.length;++e){const t=g[e],n=t.geometry;I+=4+_.encode(t.name).length,I+=4;const r=t.material;if(void 0!==r?.subMaterials){const e=r.subMaterials;I+=4;for(let t=0;t<e.length;++t)I+=4,I+=4,I+=4,I+=4,I+=4}I+=4;const i=n.getVerticesData(s.R.PositionKind);I+=4*i.length;const o=i.length/3;if(I+=3*o*4,I+=2*o*4,I+=1,null!==n.getVerticesData(f.V.AdditionalUV1Kind)&&(I+=4*o*4),null!==n.getVerticesData(f.V.AdditionalUV2Kind)&&(I+=4*o*4),null!==n.getVerticesData(f.V.AdditionalUV3Kind)&&(I+=4*o*4),null!==n.getVerticesData(f.V.AdditionalUV4Kind)&&(I+=4*o*4),I+=1,!t.isUnIndexed){I+=1,I+=4;const e=n.getIndices();I+=Array.isArray(e)?4*e.length:e.byteLength}0!==d.length&&(null===n.getVerticesData(s.R.MatricesIndicesKind)&&this.warn(`mesh ${t.name} has no matricesIndices data. falling back to zero matricesIndices`),I+=4*o*4,null===n.getVerticesData(s.R.MatricesWeightsKind)&&this.warn(`mesh ${t.name} has no matricesWeights data. falling back to zero matricesWeights`),I+=4*o*4);const a=n.getVerticesData(f.V.MatricesSdefCKind),l=n.getVerticesData(f.V.MatricesSdefR0Kind),h=n.getVerticesData(f.V.MatricesSdefR1Kind);null!==a&&null!==l&&null!==h?(I+=3*o*4,I+=3*o*4,I+=3*o*4):null!==a&&null!==l&&null!==h||null===a&&null===l&&null===h||this.warn(`mesh ${t.name} has incomplete sdef data. sdefC, sdefR0, sdefR1 must be all defined or all undefined. falling back to linear blend skinning`),null!==n.getVerticesData(f.V.EdgeScaleKind)&&(I+=4*o)}I+=4;for(let e=0;e<x.length;++e){const t=x[e];I+=4+_.encode(t.relativePath).length,I+=1,void 0!==t.mimeType&&(I+=4+_.encode(t.mimeType).length),I+=4,I+=t.buffer.byteLength}I+=4;for(let e=0;e<y.length;++e)I+=6;I+=4;for(let e=0;e<A.length;++e){const t=A[e];I+=4+_.encode(t.name).length,I+=4+_.encode(t.englishName).length,I+=16,I+=12,I+=4,I+=12,I+=1,I+=1,I+=16,I+=4,I+=4,I+=4,I+=1,I+=1,I+=4,I+=4+_.encode(t.comment).length}if(0!==d.length){I+=4,l||this.warn("metadata.bones has following missing properties: tailPosition, axisLimit, localVector, externalParentTransform. lossy conversion will be applied");for(let e=0;e<d.length;++e){const t=d[e];if(I+=4+_.encode(t.name).length,I+=4+_.encode(t.englishName).length,I+=12,I+=4,I+=4,I+=2,l?"number"==typeof t.tailPosition?I+=4:I+=12:I+=4,void 0!==t.appendTransform&&(I+=4,I+=4),void 0!==t.axisLimit&&(I+=12),void 0!==t.localVector&&(I+=12,I+=12),void 0!==t.externalParentTransform&&(I+=4),void 0!==t.ik){I+=4,I+=4,I+=4,I+=4;const e=t.ik.links;for(let t=0;t<e.length;++t)I+=4,I+=1,void 0!==e[t].limitation&&(I+=12,I+=12)}}}I+=4;const t=a.morphs;for(let e=0;e<t.length;++e){const n=t[e];switch(I+=4+_.encode(n.name).length,I+=4+_.encode(n.englishName).length,I+=1,I+=1,n.type){case b.Morph.Type.GroupMorph:I+=4+8*n.indices.length;break;case b.Morph.Type.VertexMorph:{I+=4;const t=M[e];for(let e=0;e<t.length;++e){const n=t[e];I+=8+4*n.indices.length+4*n.offsets.length}}break;case b.Morph.Type.BoneMorph:I+=4+32*n.indices.length;break;case b.Morph.Type.UvMorph:case b.Morph.Type.AdditionalUvMorph1:case b.Morph.Type.AdditionalUvMorph2:case b.Morph.Type.AdditionalUvMorph3:case b.Morph.Type.AdditionalUvMorph4:{I+=4;const t=M[e];for(let e=0;e<t.length;++e){const n=t[e];I+=8+4*n.indices.length+4*n.offsets.length}}break;case b.Morph.Type.MaterialMorph:I+=4+117*n.elements.length}}if(I+=4,l&&null!==a.displayFrames){const e=a.displayFrames;for(let t=0;t<e.length;++t){const n=e[t];I+=4+_.encode(n.name).length,I+=4+_.encode(n.englishName).length,I+=1,I+=4,I+=5*n.frames.length}}I+=4;const n=a.rigidBodies;for(let e=0;e<n.length;++e){const t=n[e];I+=4+_.encode(t.name).length,I+=4+_.encode(t.englishName).length,I+=4,I+=1,I+=2,I+=1,I+=12,I+=12,I+=12,I+=4,I+=4,I+=4,I+=4,I+=4,I+=1}I+=4;const r=a.joints;for(let e=0;e<r.length;++e){const t=r[e];I+=4+_.encode(t.name).length,I+=4+_.encode(t.englishName).length,I+=1,I+=4,I+=4,I+=12,I+=12,I+=12,I+=12,I+=12,I+=12,I+=12,I+=12}}const v=new ArrayBuffer(I),w=new Be(v);w.setUint8Array(_.encode("BPMX")),w.setInt8Array([2,2,1]);{const e=a.header;w.setString(e.modelName),w.setString(e.englishModelName),w.setString(e.comment),w.setString(e.englishComment)}const E=0!==d.length?Ie.Geometry.MeshType.IsSkinnedMesh:0;w.setUint8(E),w.setUint32(g.length);for(let e=0;e<g.length;++e){const t=g[e],n=t.geometry;w.setString(t.name);let r=!1;if(1<t.subMeshes.length||0===t.subMeshes.length)r=!0;else{const e=t.subMeshes[0];0===e.materialIndex&&0===e.verticesStart&&e.verticesCount===n.getTotalVertices()&&0===e.indexStart&&e.indexCount===n.getTotalIndices()||(r=!0)}if(r){w.setInt32(-2);const e=t.subMeshes;w.setUint32(e.length);const n=t.material?.subMaterials??[t.material];for(let t=0;t<e.length;++t){const r=e[t],i=n[r.materialIndex]??null,s=A.findIndex((e=>e.linkedMaterial===i));w.setInt32(s),w.setUint32(r.verticesStart),w.setUint32(r.verticesCount),w.setUint32(r.indexStart),w.setUint32(r.indexCount)}}else{const e=t.material,n=A.findIndex((t=>t.linkedMaterial===e));w.setInt32(n)}const i=n.getVerticesData(s.R.PositionKind),o=i.length/3;w.setUint32(o),w.setFloat32Array(i);let a=n.getVerticesData(s.R.NormalKind);if(a.length!==3*o){this.warn(`mesh ${t.name} normals vertex count is different from positions vertex count`);const e=new Float32Array(3*o);e.set(a),a=e}w.setFloat32Array(a);let l=n.getVerticesData(s.R.UVKind);if(l.length!==2*o){this.warn(`mesh ${t.name} uv vertex count is different from positions vertex count`);const e=new Float32Array(2*o);e.set(l),l=e}w.setFloat32Array(l);const h=[];{const e=n.getVerticesData(f.V.AdditionalUV1Kind);null!==e&&h.push(e);const t=n.getVerticesData(f.V.AdditionalUV2Kind);null!==t&&h.push(t);const r=n.getVerticesData(f.V.AdditionalUV3Kind);null!==r&&h.push(r);const i=n.getVerticesData(f.V.AdditionalUV4Kind);null!==i&&h.push(i)}w.setUint8(h.length);for(let e=0;e<h.length;++e){const n=h[e];if(n.length!==4*o){this.warn(`mesh ${t.name} additional uv vertex count is different from positions vertex count`);const r=new Float32Array(4*o);r.set(n),h[e]=r}w.setFloat32Array(n)}let c=n.getVerticesData(f.V.MatricesSdefCKind),u=n.getVerticesData(f.V.MatricesSdefR0Kind),m=n.getVerticesData(f.V.MatricesSdefR1Kind);const x=null!==c&&null!==u&&null!==m;let y=n.getVerticesData(f.V.EdgeScaleKind);const T=(x?Ie.Geometry.GeometryType.HasSdef:0)|(t.isUnIndexed?0:Ie.Geometry.GeometryType.IsIndexed)|(null!==y?Ie.Geometry.GeometryType.HasEdgeScale:0);if(w.setUint8(T),!t.isUnIndexed){const e=n.getIndices();w.setUint8(e instanceof Uint32Array?Ie.Geometry.IndexElementType.Uint32:e instanceof Uint16Array?Ie.Geometry.IndexElementType.Uint16:Ie.Geometry.IndexElementType.Int32),w.setUint32(e.length),e instanceof Uint16Array?w.setUint16Array(e):e instanceof Uint32Array?w.setUint32Array(e):w.setInt32Array(e)}if(0!==d.length){const e=new Float32Array(4*o);{const r=n.getVerticesData(s.R.MatricesIndicesKind);if(null!==r&&r.length===4*o||this.warn(`mesh ${t.name} bone indices vertex count is different from positions vertex count`),null!==r)for(let t=0;t<e.length;++t)e[t]=p[r[t]]??r[t]}w.setFloat32Array(e);let r=n.getVerticesData(s.R.MatricesWeightsKind);if(null===r&&(r=new Float32Array(4*o)),r.length!==4*o){this.warn(`mesh ${t.name} bone weights vertex count is different from positions vertex count`);const e=new Float32Array(4*o);e.set(r),r=e}if(w.setFloat32Array(r),x){if(c.length!==3*o){this.warn(`mesh ${t.name} sdefC vertex count is different from positions vertex count`);const e=new Float32Array(3*o);e.set(c),c=e}if(u.length!==3*o){this.warn(`mesh ${t.name} sdefR0 vertex count is different from positions vertex count`);const e=new Float32Array(3*o);e.set(u),u=e}if(m.length!==3*o){this.warn(`mesh ${t.name} sdefR1 vertex count is different from positions vertex count`);const e=new Float32Array(3*o);e.set(m),m=e}w.setFloat32Array(c),w.setFloat32Array(u),w.setFloat32Array(m)}}if(null!==y){if(y.length!==o){this.warn(`mesh ${t.name} edgeScale vertex count is different from positions vertex count`);const e=new Float32Array(o);e.set(y),y=e}w.setFloat32Array(y)}}w.setUint32(x.length);for(let e=0;e<x.length;++e){const t=x[e];w.setString(t.relativePath);const n=void 0!==t.mimeType?Ie.Image.Flag.HasMimeType:0;w.setUint8(n),void 0!==t.mimeType&&w.setString(t.mimeType),w.setUint32(t.buffer.byteLength),w.setUint8Array(t.buffer)}w.setUint32(y.length);for(let e=0;e<y.length;++e){const t=y[e];w.setUint8(t.flag),w.setUint8(t.samplingMode),w.setInt32(t.imageIndex)}w.setUint32(A.length);for(let e=0;e<A.length;++e){const t=A[e];w.setString(t.name),w.setString(t.englishName),w.setFloat32Array(t.diffuse),w.setFloat32Array(t.specular),w.setFloat32(t.shininess),w.setFloat32Array(t.ambient),w.setUint8(t.evaluatedTransparency),w.setUint8(t.flag),w.setFloat32Array(t.edgeColor),w.setFloat32(t.edgeSize),w.setInt32(t.textureIndex),w.setInt32(t.sphereTextureIndex),w.setUint8(t.sphereTextureMode),w.setUint8(t.isSharedToonTexture?1:0),w.setInt32(t.toonTextureIndex),w.setString(t.comment)}if(0!==d.length){w.setUint32(d.length);for(let e=0;e<d.length;++e){const t=d[e];if(w.setString(t.name),w.setString(t.englishName),w.setFloat32Array(t.position),w.setInt32(t.parentBoneIndex),w.setInt32(t.transformOrder),w.setUint16(t.flag),"number"==typeof t.tailPosition?w.setInt32(t.tailPosition):w.setFloat32Array(t.tailPosition),void 0!==t.appendTransform&&(w.setInt32(t.appendTransform.parentIndex),w.setFloat32(t.appendTransform.ratio)),void 0!==t.axisLimit&&w.setFloat32Array(t.axisLimit),void 0!==t.localVector&&(w.setFloat32Array(t.localVector.x),w.setFloat32Array(t.localVector.z)),void 0!==t.externalParentTransform&&w.setInt32(t.externalParentTransform),void 0!==t.ik){const e=t.ik;w.setInt32(e.target),w.setInt32(e.iteration),w.setFloat32(e.rotationConstraint);const n=e.links;w.setInt32(n.length);for(let e=0;e<n.length;++e){const t=n[e];w.setInt32(t.target),w.setUint8(void 0!==t.limitation?1:0),void 0!==t.limitation&&(w.setFloat32Array(t.limitation.minimumAngle),w.setFloat32Array(t.limitation.maximumAngle))}}}}w.setUint32(a.morphs.length);const S=a.morphs;for(let e=0;e<S.length;++e){const t=S[e];switch(w.setString(t.name),w.setString(t.englishName),w.setUint8(t.category),w.setUint8(t.type),t.type){case b.Morph.Type.GroupMorph:{w.setUint32(t.indices.length),w.setInt32Array(t.indices);let e=t.ratios;if(e.length!==t.indices.length){this.warn(`morph ${t.name} group morph ratio count is different from indices count`);const n=new Float32Array(t.indices.length);n.set(e),e=n}w.setFloat32Array(e)}break;case b.Morph.Type.VertexMorph:case b.Morph.Type.UvMorph:case b.Morph.Type.AdditionalUvMorph1:case b.Morph.Type.AdditionalUvMorph2:case b.Morph.Type.AdditionalUvMorph3:case b.Morph.Type.AdditionalUvMorph4:{const n=M[e];w.setUint32(n.length);for(let e=0;e<n.length;++e){const r=n[e];w.setUint32(r.meshIndex),w.setUint32(r.indices.length),w.setInt32Array(r.indices);let i=r.offsets;const s=t.type===b.Morph.Type.VertexMorph?3:4;if(i.length!==r.indices.length*s){this.warn(`morph ${t.name} vertex/uv morph offset count is different from indices count`);const e=new Float32Array(r.indices.length*s);e.set(i),i=e}w.setFloat32Array(i)}}break;case b.Morph.Type.BoneMorph:{const e=new Int32Array(t.indices.length);{const n=t.indices;for(let t=0;t<n.length;++t)e[t]=h[n[t]]??n[t]}w.setUint32(e.length),w.setInt32Array(e);let n=t.positions;if(n.length!==3*e.length){this.warn(`morph ${t.name} bone morph position count is different from indices count`);const r=new Float32Array(3*e.length);r.set(n),n=r}w.setFloat32Array(n);let r=t.rotations;if(r.length!==4*e.length){this.warn(`morph ${t.name} bone morph rotation count is different from indices count`);const n=new Float32Array(4*e.length);n.set(r),r=n}w.setFloat32Array(r)}break;case b.Morph.Type.MaterialMorph:{w.setUint32(t.elements.length);const e=t.elements;for(let t=0;t<e.length;++t){const n=e[t],r=T.get(n.index)??n.index;w.setInt32(r),w.setUint8(n.type),w.setFloat32Array(n.diffuse),w.setFloat32Array(n.specular),w.setFloat32(n.shininess),w.setFloat32Array(n.ambient),w.setFloat32Array(n.edgeColor),w.setFloat32(n.edgeSize),w.setFloat32Array(n.textureColor),w.setFloat32Array(n.sphereTextureColor),w.setFloat32Array(n.toonTextureColor)}}break;default:w.setUint32(0)}}if(l&&null!==a.displayFrames){w.setUint32(a.displayFrames.length);const e=a.displayFrames;for(let t=0;t<e.length;++t){const n=e[t];w.setString(n.name),w.setString(n.englishName),w.setUint8(n.isSpecialFrame?1:0),w.setUint32(n.frames.length);const r=n.frames;for(let e=0;e<r.length;++e){const t=r[e];w.setUint8(t.type);const n=t.type===b.DisplayFrame.FrameData.FrameType.Bone?h[t.index]??t.index:t.index;w.setInt32(n)}}}else w.setUint32(0);w.setUint32(a.rigidBodies.length);const C=a.rigidBodies;for(let e=0;e<C.length;++e){const t=C[e];w.setString(t.name),w.setString(t.englishName),w.setInt32(h[t.boneIndex]??t.boneIndex),w.setUint8(t.collisionGroup),w.setUint16(t.collisionMask),w.setUint8(t.shapeType),w.setFloat32Array(t.shapeSize),w.setFloat32Array(t.shapePosition),w.setFloat32Array(t.shapeRotation),w.setFloat32(t.mass),w.setFloat32(t.linearDamping),w.setFloat32(t.angularDamping),w.setFloat32(t.repulsion),w.setFloat32(t.friction),w.setUint8(t.physicsMode)}w.setUint32(a.joints.length);const F=a.joints;for(let e=0;e<F.length;++e){const t=F[e];w.setString(t.name),w.setString(t.englishName),w.setUint8(t.type),w.setInt32(t.rigidbodyIndexA),w.setInt32(t.rigidbodyIndexB),w.setFloat32Array(t.position),w.setFloat32Array(t.rotation),w.setFloat32Array(t.positionMin),w.setFloat32Array(t.positionMax),w.setFloat32Array(t.rotationMin),w.setFloat32Array(t.rotationMax),w.setFloat32Array(t.springPosition),w.setFloat32Array(t.springRotation)}return 0!==w.bytesAvailable&&this.error(`unexpected bytes available: ${w.bytesAvailable}`),v}get loggingEnabled(){return this._loggingEnabled}set loggingEnabled(e){this._loggingEnabled=e,e?(this.log=this._logEnabled,this.warn=this._warnEnabled,this.error=this._errorEnabled):(this.log=this._logDisabled,this.warn=this._warnDisabled,this.error=this._errorDisabled)}_logEnabled(e){O.V.Log(e)}_logDisabled(){}_warnEnabled(e){O.V.Warn(e)}_warnDisabled(){}_errorEnabled(e){O.V.Error(e)}_errorDisabled(){}}class Ue{static OverrideComputeTransformMatrices(e){e._computeTransformMatrices=function(e,t){this.onBeforeComputeObservable.notifyObservers(this);for(let n=0;n<this.bones.length;n++){const r=this.bones[n];if(r._childUpdateId+=1,!r.getParent()){const i=[r];for(;i.length>0;){const r=i.pop(),s=r.getParent();if(s?r.getLocalMatrix().multiplyToRef(s.getFinalMatrix(),r.getFinalMatrix()):t?r.getLocalMatrix().multiplyToRef(t,r.getFinalMatrix()):r.getFinalMatrix().copyFrom(r.getLocalMatrix()),-1!==r._index){const t=null===r._index?n:r._index;r.getAbsoluteInverseBindMatrix().multiplyToArray(r.getFinalMatrix(),e,16*t)}const o=r.getChildren();for(const e of o)i.push(e)}}}this._identity.copyToArray(e,16*this.bones.length)}}}async function De(e,t=""){const n=[];for(let r=0;r<e.length;++r){const i=e[r];if(i.isDirectory){const e=i.createReader(),r=await new Promise(((t,n)=>{e.readEntries(t,n)}));n.push(...await De(r,t+i.name+"/"))}else n.push(i)}return n}const Pe=document.createElement("canvas");Pe.style.width="100%",Pe.style.height="100%",Pe.style.display="block",document.body.appendChild(Pe);const ke=new r.N(Pe,!1,{preserveDrawingBuffer:!1,stencil:!1,antialias:!0,alpha:!0,premultipliedAlpha:!1,powerPreference:"high-performance",doNotHandleTouchAction:!0,doNotHandleContextLost:!0,audioEngine:!1,disableWebGL2Support:!1},!0);i.Create({canvas:Pe,engine:ke,sceneBuilder:new class{async build(e,t){T.OverrideEngineCreateEffect(t);const n=new ce;n.deleteTextureBufferAfterLoad=!1,n.renderMethod=ae.AlphaEvaluation;const r=new p.Z(t);r.ambientColor=new z.v9(.5,.5,.5);const i=new ve.L("camera",0,0,45,new u.Pq(0,10,0),r);i.maxZ=5e3,i.fov=Math.PI/180*30,i.speed=.5,i.setPosition(new u.Pq(0,10,-45)),i.attachControl(e,!0);const s=new Ee.g("hemisphericLight",new u.Pq(0,1,0),r);s.intensity=.5,s.specular=new z.v9(0,0,0),s.groundColor=new z.v9(1,1,1);const o=new we.Z("directionalLight",new u.Pq(.5,-1,1),r);o.intensity=.5,o.autoCalcShadowZBounds=!1,o.autoUpdateExtends=!1,o.shadowMaxZ=60,o.shadowMinZ=-30,o.orthoTop=54,o.orthoBottom=-3,o.orthoLeft=-30,o.orthoRight=30,o.shadowOrthoScale=0;const a=new Se.o(1024,o,!0,i);a.transparencyShadow=!0,a.usePercentageCloserFiltering=!0,a.forceBackFacesOnly=!1,a.bias=.01,a.filteringQuality=Se.o.QUALITY_MEDIUM,a.frustumEdgeFalloff=.1,(0,Ce.km)("ground1",{width:100,height:100,subdivisions:2,updatable:!1},r).receiveShadows=!0;const l=new Fe.e("default",!0,r);l.samples=4,l.fxaaEnabled=!0,l.imageProcessingEnabled=!1;const d=new he(r),h=async e=>{if(y)return;if(null!==g){for(const e of g.metadata.meshes)a.removeShadowCaster(e);g.dispose(!1,!0),g=null}y=!0,t.displayLoadingUI();const i=e.webkitRelativePath;R.textContent=e.name,g=await(0,I.kS)(e,r,{onProgress:n=>t.loadingUIText=`<br/><br/><br/>Loading (${e.name})... ${n.loaded}/${n.total} (${Math.floor(100*n.loaded/n.total)}%)`,rootUrl:i.substring(0,i.lastIndexOf("/")+1),pluginOptions:{mmdmodel:{materialBuilder:n,buildSkeleton:!0,buildMorph:!0,boundingBoxMargin:0,preserveSerializationData:$.checked,loggingEnabled:!0,referenceFiles:E}}}).then((e=>{e.addAllToScene();const t=e.meshes[0];return Ue.OverrideComputeTransformMatrices(t.metadata.skeleton),t.metadata.skeleton?._markAsDirty(),t}));{const e=g.metadata.meshes;for(let t=0;t<e.length;++t){const n=e[t];n.receiveShadows=!0,a.addShadowCaster(n,!1),n.alphaIndex=t}const t=g.metadata.materials;f.length=t.length,m.length=t.length;for(let n=0;n<t.length;++n){const r=t[n],i=r.diffuseTexture;if(i&&(i.hasAlpha=!0,r.useAlphaFromDiffuseTexture=!0),r.alpha<1)f[n]=!0;else if(i){f[n]=!0;const t=e.filter((e=>e.material===r));for(const e of t)if(await d.hasFragmentsOnlyOpaqueOnGeometry(i,e,null)){f[n]=!1;break}}else f[n]=!1;m[n]=r.transparencyMode??-1}}G(),t.hideLoadingUI(),setTimeout((()=>y=!1),1500)};let c=null,g=null;const f=[],m=[];let x="Alpha Mode",y=!1;const A=e=>{if(null===g)return;const t=g.metadata.materials;if("Alpha Mode"===e)for(let e=0;e<t.length;++e){const n=t[e];n.transparencyMode=m[e]??N.i.MATERIAL_OPAQUE,n.forceDepthWrite=!1}else for(let e=0;e<t.length;++e){const n=t[e];n.transparencyMode=f[e]?N.i.MATERIAL_ALPHABLEND:N.i.MATERIAL_OPAQUE,n.forceDepthWrite=!0}},M=e.parentElement;M.style.display="flex",M.style.flexDirection="row-reverse";const _=document.createElement("div");_.style.width="100%",_.style.height="100%",_.style.display="flex",_.appendChild(e),M.appendChild(_);const b=document.createElement("div");b.style.position="relative",b.style.backgroundColor="white",b.style.width="auto",b.style.height="100%",b.style.display="flex",b.style.flexDirection="column",b.style.justifyContent="center",b.style.alignItems="center",b.style.fontFamily="sans-serif",M.appendChild(b);const v=document.createElement("div");v.style.width="auto",v.style.height="100%",v.style.display="flex",v.style.flexDirection="column",v.style.justifyContent="center",v.style.alignItems="start",v.style.padding="20px",v.style.boxSizing="border-box",b.appendChild(v);const w=new Re;w.loggingEnabled=!0;let E=[];const S=document.createElement("h1");S.textContent="PMX to BPMX Converter",S.style.width="350px",S.style.textAlign="center",S.style.fontSize="24px",S.style.marginTop="0",v.appendChild(S);const C=document.createElement("div");C.style.width="350px",C.style.height="auto",C.style.display="flex",C.style.flexDirection="row",C.style.justifyContent="space-between",C.style.alignItems="center",v.appendChild(C);const F=document.createElement("div");F.textContent="Load Model",F.style.width="100%",F.style.height="auto",F.style.border="none",F.style.backgroundColor="#111111",F.style.fontSize="20px",F.style.textAlign="center",F.style.color="white",F.style.cursor="pointer",F.onclick=()=>{F.style.backgroundColor="#444444",B.style.backgroundColor="#111111",V.style.display="block",U.style.display="block",D.style.display="block",L.style.display="none",q.style.display="none",K.style.display="none"},C.appendChild(F);const B=document.createElement("div");B.textContent="Fix Material",B.style.width="100%",B.style.height="auto",B.style.border="none",B.style.backgroundColor="#111111",B.style.fontSize="20px",B.style.textAlign="center",B.style.color="white",B.style.cursor="pointer",B.onclick=()=>{F.style.backgroundColor="#111111",B.style.backgroundColor="#444444",V.style.display="none",U.style.display="none",D.style.display="none",L.style.display="flex",q.style.display="block",K.style.display="block"},C.appendChild(B);const R=document.createElement("div");R.textContent="No PMX file selected",R.style.width="350px",R.style.height="auto",R.style.fontSize="18px",R.style.marginBottom="10px",R.style.border="1px solid black",R.style.boxSizing="border-box",R.style.padding="10px",R.style.overflow="scroll",v.appendChild(R);const U=document.createElement("div");U.textContent="Files",U.style.width="100%",U.style.height="auto",U.style.fontSize="18px",U.style.backgroundColor="#444444",U.style.color="white",U.style.padding="2px 5px",U.style.boxSizing="border-box",v.appendChild(U);const D=document.createElement("div");D.style.width="350px",D.style.flexGrow="1",D.style.overflow="auto",D.style.marginBottom="10px",D.style.border="1px solid black",D.style.boxSizing="border-box",v.appendChild(D);const P=document.createElement("ul");P.style.height="auto",P.style.fontSize="16px",D.appendChild(P);const k=()=>{P.innerHTML="";for(const e of E){const t=document.createElement("li");t.style.whiteSpace="nowrap";const n=e.webkitRelativePath;t.textContent=n.substring(n.indexOf("/")+1),(e.name.endsWith(".pmx")||e.name.endsWith(".pmd"))&&(t.style.color="blue",t.style.cursor="pointer",t.style.textDecoration="underline",t.onclick=()=>{c=e,h(e)}),P.appendChild(t)}},V=document.createElement("input");V.style.width="100%",V.style.minHeight="80px",V.style.display="block",V.style.backgroundColor="black",V.style.color="white",V.style.marginBottom="10px",V.style.fontSize="20px",V.type="file",V.setAttribute("directory",""),V.setAttribute("webkitdirectory",""),V.setAttribute("allowdirs",""),V.ondragover=e=>{e.preventDefault()},V.ondrop=async e=>{e.preventDefault();const t=e.dataTransfer.items;if(!t)return;const n=[];for(let e=0;e<t.length;++e){const r=t[e].webkitGetAsEntry();r&&n.push(r)}const r=await De(n);E=await async function(e){const t=[],n=await De(e);for(let e=0;e<n.length;++e){const r=n[e],i=await new Promise(((e,t)=>{r.file(e,t)}));""===i.webkitRelativePath&&(Object.defineProperty(i,"webkitRelativePath",{writable:!0}),i.webkitRelativePath=r.fullPath),t.push(i)}return t}(r),k()},V.onchange=()=>{null!==V.files&&(E=Array.from(V.files),k())},v.appendChild(V);const L=document.createElement("div");L.style.width="100%",L.style.height="auto",L.style.display="flex",L.style.flexDirection="row",L.style.justifyContent="space-between",v.appendChild(L);const O=document.createElement("button");O.textContent="Alpha Mode",O.style.flexGrow="1",O.style.height="auto",O.style.border="none",O.style.fontSize="16px",O.style.backgroundColor="#444444",O.style.color="white",O.style.cursor="pointer",O.onclick=()=>{"Alpha Mode"!==x&&(O.style.backgroundColor="#444444",W.style.backgroundColor="#111111",x="Alpha Mode",A(x),G())},L.appendChild(O);const W=document.createElement("button");W.textContent="Force Depth Write Mode",W.style.flexGrow="1",W.style.height="auto",W.style.border="none",W.style.fontSize="16px",W.style.backgroundColor="#111111",W.style.color="white",W.style.cursor="pointer",W.onclick=()=>{"Force Depth Write Mode"!==x&&(O.style.backgroundColor="#111111",W.style.backgroundColor="#444444",x="Force Depth Write Mode",A(x),G())},L.appendChild(W);const q=document.createElement("div");q.textContent="Materials",q.style.width="100%",q.style.height="auto",q.style.fontSize="18px",q.style.backgroundColor="#444444",q.style.color="white",q.style.padding="2px 5px",q.style.boxSizing="border-box",v.appendChild(q);const K=document.createElement("div");K.style.width="350px",K.style.flexGrow="1",K.style.overflow="auto",K.style.marginBottom="10px",K.style.border="1px solid black",K.style.boxSizing="border-box",v.appendChild(K);const H=document.createElement("ol");H.start=0,H.style.height="auto",H.style.fontSize="16px",K.appendChild(H);const G=()=>{if(H.innerHTML="",null===g)return;const e=g.metadata.meshes;for(let n=0;n<e.length;++n){const r=e[n].material,i=document.createElement("li");if(i.style.padding="5px 0px",i.style.boxSizing="border-box",i.style.whiteSpace="nowrap",i.textContent=r.name,"Alpha Mode"===x){const e=document.createElement("button");e.style.float="right",e.style.width="100px",e.style.height="auto",e.style.fontSize="14px",e.style.marginRight="10px",e.style.border="none",e.textContent=t(r.transparencyMode??0);const s=n;e.onclick=()=>{null===r.transparencyMode&&(r.transparencyMode=0),r.transparencyMode=(r.transparencyMode+1)%3,m[s]=r.transparencyMode,e.textContent=t(r.transparencyMode??0)},i.appendChild(e)}else{const e=document.createElement("button");e.style.float="right",e.style.width="100px",e.style.height="auto",e.style.fontSize="14px",e.style.marginRight="10px",e.style.border="none",e.textContent=r.transparencyMode===N.i.MATERIAL_OPAQUE?"Opaque":"Alpha Blend";const t=n;e.onclick=()=>{r.transparencyMode=r.transparencyMode===N.i.MATERIAL_OPAQUE?N.i.MATERIAL_ALPHABLEND:N.i.MATERIAL_OPAQUE,f[t]=r.transparencyMode===N.i.MATERIAL_ALPHABLEND,e.textContent=r.transparencyMode===N.i.MATERIAL_OPAQUE?"Opaque":"Alpha Blend"},i.appendChild(e)}H.appendChild(i)}function t(e){switch(e){case N.i.MATERIAL_OPAQUE:return"Opaque";case N.i.MATERIAL_ALPHATEST:return"Alpha Test";case N.i.MATERIAL_ALPHABLEND:return"Alpha Blend";default:return"Unknown"}}},Q=document.createElement("div");Q.style.width="100%",Q.style.height="auto",Q.style.display="flex",Q.style.flexDirection="column",Q.style.justifyContent="center",Q.style.alignItems="center",Q.style.marginBottom="10px",Q.style.border="1px solid black",Q.style.padding="20px",Q.style.boxSizing="border-box",v.appendChild(Q);const X=document.createElement("div");X.style.width="100%",X.style.height="30px",X.style.display="flex",X.style.flexDirection="row",X.style.justifyContent="space-between",X.style.alignItems="center",X.style.marginBottom="10px",Q.appendChild(X);const Y=document.createElement("label");Y.textContent="Preserve Serialization Data",Y.title="If enabled, the converted file will be larger, but the converted file will be able to be converted back to PMX without any loss of data in technically(currently BPMX to PMX conversion is not supported).",Y.style.textAlign="left",Y.style.marginRight="10px",Y.style.fontSize="16px",X.appendChild(Y);const j=document.createElement("label");j.textContent="(reload required)",j.style.fontSize="11px",j.style.color="gray",j.style.flexGrow="1",X.appendChild(j);const $=document.createElement("input");$.style.width="16px",$.style.height="16px",$.type="checkbox",$.checked=!0,X.appendChild($),$.onclick=e=>{y?e.preventDefault():null!==c&&h(c)};const J=document.createElement("div");J.style.width="100%",J.style.height="30px",J.style.display="flex",J.style.flexDirection="row",J.style.justifyContent="space-between",J.style.alignItems="center",J.style.marginBottom="10px",Q.appendChild(J);const Z=document.createElement("label");Z.textContent="Build Skeleton",Z.title="If your model don't need to be animated by skeleton(e.g. stage model), you can disable this option to reduce the size of the converted file. also, it can improve the performance of the converted model.",Z.style.textAlign="left",Z.style.marginRight="10px",Z.style.fontSize="16px",Z.style.flexGrow="1",J.appendChild(Z);const ee=document.createElement("input");ee.style.width="16px",ee.style.height="16px",ee.type="checkbox",ee.checked=!0,J.appendChild(ee);const te=document.createElement("div");te.style.width="100%",te.style.height="30px",te.style.display="flex",te.style.flexDirection="row",te.style.justifyContent="space-between",te.style.alignItems="center",te.style.marginBottom="10px",Q.appendChild(te);const ne=document.createElement("label");ne.textContent="Build Morph",ne.title="If your model don't need to be animated by morph targets(e.g. stage model), you can disable this option to reduce the size of the converted file. also, it can improve the performance of the converted model.",ne.style.textAlign="left",ne.style.marginRight="10px",ne.style.fontSize="16px",ne.style.flexGrow="1",te.appendChild(ne);const re=document.createElement("input");re.style.width="16px",re.style.height="16px",re.type="checkbox",re.checked=!0,te.appendChild(re);const ie=document.createElement("div");ie.style.width="100%",ie.style.height="auto",ie.style.display="flex",ie.style.flexDirection="row",ie.style.justifyContent="space-between",ie.style.alignItems="center",v.appendChild(ie);const se=document.createElement("button");return se.textContent="Convert",se.style.width="100%",se.style.height="60px",se.style.border="none",se.style.fontSize="20px",ie.appendChild(se),se.onclick=async()=>{if(y)return;if(null===c)return;if(null===g)return;y=!0,t.displayLoadingUI(),t.loadingUIText=`<br/><br/><br/>Converting (${c.name})...`;const e=w.convert(g,{includeSkinningData:ee.checked,includeMorphData:re.checked,translucentMaterials:f,alphaEvaluateResults:m}),n=new Blob([e],{type:"application/octet-stream"}),r=URL.createObjectURL(n),i=document.createElement("a");i.href=r,i.download=`${c.name.substring(0,c.name.lastIndexOf("."))}.bpmx`,i.click(),URL.revokeObjectURL(r),i.remove(),await new Promise((e=>{setTimeout((()=>{t.hideLoadingUI(),e()}),1500)})),y=!1},F.click(),t.resize(!0),r}}}).then((e=>e.run()))}},i={};function s(e){var t=i[e];if(void 0!==t)return t.exports;var n=i[e]={exports:{}};return r[e](n,n.exports,s),n.exports}s.m=r,e=[],s.O=(t,n,r,i)=>{if(!n){var o=1/0;for(h=0;h<e.length;h++){for(var[n,r,i]=e[h],a=!0,l=0;l<n.length;l++)(!1&i||o>=i)&&Object.keys(s.O).every((e=>s.O[e](n[l])))?n.splice(l--,1):(a=!1,i<o&&(o=i));if(a){e.splice(h--,1);var d=r();void 0!==d&&(t=d)}}return t}i=i||0;for(var h=e.length;h>0&&e[h-1][2]>i;h--)e[h]=e[h-1];e[h]=[n,r,i]},s.d=(e,t)=>{for(var n in t)s.o(t,n)&&!s.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},s.f={},s.e=e=>Promise.all(Object.keys(s.f).reduce(((t,n)=>(s.f[n](e,t),t)),[])),s.u=e=>(({71:"glslShaders",126:"wgslShaders"}[e]||e)+".bundle.js"),s.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),s.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),t={},n="babylon-mmd:",s.l=(e,r,i,o)=>{if(t[e])t[e].push(r);else{var a,l;if(void 0!==i)for(var d=document.getElementsByTagName("script"),h=0;h<d.length;h++){var c=d[h];if(c.getAttribute("src")==e||c.getAttribute("data-webpack")==n+i){a=c;break}}a||(l=!0,(a=document.createElement("script")).charset="utf-8",a.timeout=120,s.nc&&a.setAttribute("nonce",s.nc),a.setAttribute("data-webpack",n+i),a.src=e),t[e]=[r];var u=(n,r)=>{a.onerror=a.onload=null,clearTimeout(p);var i=t[e];if(delete t[e],a.parentNode&&a.parentNode.removeChild(a),i&&i.forEach((e=>e(r))),n)return n(r)},p=setTimeout(u.bind(null,void 0,{type:"timeout",target:a}),12e4);a.onerror=u.bind(null,a.onerror),a.onload=u.bind(null,a.onload),l&&document.head.appendChild(a)}},s.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{var e;s.g.importScripts&&(e=s.g.location+"");var t=s.g.document;if(!e&&t&&(t.currentScript&&"SCRIPT"===t.currentScript.tagName.toUpperCase()&&(e=t.currentScript.src),!e)){var n=t.getElementsByTagName("script");if(n.length)for(var r=n.length-1;r>-1&&(!e||!/^http(s?):/.test(e));)e=n[r--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),s.p=e})(),(()=>{var e={792:0};s.f.j=(t,n)=>{var r=s.o(e,t)?e[t]:void 0;if(0!==r)if(r)n.push(r[2]);else{var i=new Promise(((n,i)=>r=e[t]=[n,i]));n.push(r[2]=i);var o=s.p+s.u(t),a=new Error;s.l(o,(n=>{if(s.o(e,t)&&(0!==(r=e[t])&&(e[t]=void 0),r)){var i=n&&("load"===n.type?"missing":n.type),o=n&&n.target&&n.target.src;a.message="Loading chunk "+t+" failed.\n("+i+": "+o+")",a.name="ChunkLoadError",a.type=i,a.request=o,r[1](a)}}),"chunk-"+t,t)}},s.O.j=t=>0===e[t];var t=(t,n)=>{var r,i,[o,a,l]=n,d=0;if(o.some((t=>0!==e[t]))){for(r in a)s.o(a,r)&&(s.m[r]=a[r]);if(l)var h=l(s)}for(t&&t(n);d<o.length;d++)i=o[d],s.o(e,i)&&e[i]&&e[i][0](),e[i]=0;return s.O(h)},n=self.webpackChunkbabylon_mmd=self.webpackChunkbabylon_mmd||[];n.forEach(t.bind(null,0)),n.push=t.bind(null,n.push.bind(n))})();var o=s.O(void 0,[833],(()=>s(8822)));o=s.O(o)})();